"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.importSqlCheckStatus = importSqlCheckStatus;
var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _dbFileImport = require("./db-file-import");
var _api = _interopRequireDefault(require("../../lib/api"));
var exit = _interopRequireWildcard(require("../../lib/cli/exit"));
var _format = require("../../lib/cli/format");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/* eslint-disable complexity */

const debug = (0, _debug.default)('vip:lib/site-import/status');
const IMPORT_SQL_PROGRESS_POLL_INTERVAL = 5000;
const IMPORT_SQL_PROGRESS_QUERY = (0, _graphqlTag.default)`
	query App($appId: Int, $envId: Int) {
		app(id: $appId) {
			environments(id: $envId) {
				id
				isK8sResident
				launched
				jobs(types: "sql_import") {
					id
					type
					completedAt
					createdAt
					progress {
						status
						steps {
							id
							name
							status
						}
					}
				}
				importStatus {
					dbOperationInProgress
					importInProgress
					progress {
						started_at
						steps {
							name
							started_at
							finished_at
							result
							output
						}
						finished_at
					}
				}
			}
		}
	}
`;
async function getStatus(api, appId, envId) {
  const response = await api.query({
    query: IMPORT_SQL_PROGRESS_QUERY,
    variables: {
      appId,
      envId
    },
    fetchPolicy: 'network-only'
  });
  const environments = response.data.app?.environments ?? [];
  if (!environments.length) {
    throw new Error('Unable to determine import status from environment');
  }
  const environment = environments[0] ?? {};
  const {
    importStatus,
    jobs,
    launched
  } = environment;
  if (!environment.isK8sResident && !jobs?.length) {
    return {};
  }
  const [importJob] = jobs ?? [];
  return {
    importStatus,
    importJob,
    launched
  };
}
function getErrorMessage(importFailed, launched = false) {
  debug({
    importFailed
  });
  const rollbackMessage = launched ? '' : `Your site is ${_chalk.default.blue('automatically being rolled back')} to the last backup prior to your import job.
`;
  let message = importFailed.error;
  if (importFailed.inImportProgress) {
    switch (importFailed.stepName) {
      case 'import_preflights':
        message += `
This error occurred prior to the mysql batch script processing of your SQL file.

Your site content was not altered.

If this error persists, please contact support.
`;
        break;
      case 'importing_db':
        message += `
This error occurred during the mysql batch script processing of your SQL file.

${rollbackMessage}`;
        if (importFailed.commandOutput) {
          const commandOutput = [].concat(importFailed.commandOutput).join(';');
          message += `
Please inspect your input file and make the appropriate corrections before trying again.
The server said:
> ${_chalk.default.red(commandOutput)}
`;
        } else {
          message += 'Please contact support and include this message along with your sql file.';
        }
        break;
      case 'validating_db':
        message += `\nThis error occurred during the post-import validation of the imported data.

${rollbackMessage}
`;
        if (importFailed.commandOutput) {
          const commandOutput = [].concat(importFailed.commandOutput).join(';');
          message += `
Please inspect your input file and make the appropriate corrections before trying again.
The server said:
> ${_chalk.default.red(commandOutput)}
`;
        } else {
          message += 'Please contact support and include this message along with your sql file.';
        }
        break;
      default:
    }
  }
  return message;
}
async function importSqlCheckStatus({
  app,
  env,
  progressTracker,
  shouldReturnMissingJobImmediately = false // we want to return fast only if we're checking the status via `vip import job status`
}) {
  // Stop printing so we can pass our callback
  progressTracker.stopPrinting();

  // NO `console.log` in this function (until results are final)! It will break the progress printing.
  const api = (0, _api.default)();
  if (!(0, _dbFileImport.currentUserCanImportForApp)(app)) {
    throw new Error('The currently authenticated account does not have permission to view SQL import status.');
  }
  let createdAt;
  let completedAt;
  let overallStatus = 'Checking...';
  const setProgressTrackerSuffix = () => {
    const sprite = (0, _format.getGlyphForStatus)(overallStatus, progressTracker.runningSprite);
    const formattedCreatedAt = createdAt ? `${new Date(createdAt).toLocaleString()} (${createdAt})` : 'TBD';
    const formattedCompletedAt = createdAt && completedAt ? `${new Date(completedAt).toLocaleString()} (${completedAt})` : 'TBD';
    const exitPrompt = '(Press ^C to hide progress. The import will continue in the background.)';
    let statusMessage;
    switch (overallStatus) {
      case 'success':
        statusMessage = `Success ${sprite} imported data should be visible on your site ${env.primaryDomain?.name ?? 'N/A'}.`;
        break;
      case 'running':
        if (progressTracker.allStepsSucceeded()) {
          statusMessage = `Finishing up... ${sprite} `;
          break;
        }
      // Intentionally no break to get default case:
      // eslint-disable-next-line no-fallthrough
      default:
        statusMessage = `${(0, _format.capitalize)(overallStatus)} ${sprite}`;
    }
    const maybeExitPrompt = `${overallStatus === 'running' ? exitPrompt : ''}`;
    const jobCreateCompleteTimestamps = `
SQL Import Started: ${formattedCreatedAt}
SQL Import Completed: ${formattedCompletedAt}`;
    const maybeTimestamps = ['running', 'success', 'failed'].includes(overallStatus) ? jobCreateCompleteTimestamps : '';
    const suffix = `
=============================================================
Status: ${statusMessage}
Site: ${app.name ?? 'N/A'} (${(0, _format.formatEnvironment)(env.type ?? 'N/A')})${maybeTimestamps}
=============================================================
${maybeExitPrompt}
`;
    progressTracker.suffix = suffix;
  };
  const setSuffixAndPrint = () => {
    setProgressTrackerSuffix();
    progressTracker.print();
  };
  progressTracker.startPrinting(setSuffixAndPrint);
  const getResults = () => new Promise((resolve, reject) => {
    const checkStatus = async () => {
      let status;
      try {
        status = await getStatus(api, app.id ?? -1, env.id ?? -1);
      } catch (error) {
        return reject({
          error
        });
      }
      const {
        importStatus,
        launched
      } = status;
      // we want the "vip import job status" command to fail fast if we have no import job.
      const isMissingImportJobAndShouldReturnFast = !status.importJob && shouldReturnMissingJobImmediately;
      let {
        importJob
      } = status;
      let jobStatus;
      let jobSteps = [];
      if (env.isK8sResident && !isMissingImportJobAndShouldReturnFast) {
        // in the future the API may provide this in k8s jobs so account for that.
        // Until then we need to create the importJob from the status object.
        if (!importJob) {
          importJob = {};
          const statusSteps = importStatus?.progress?.steps;
          // if the progress meta isn't filled out yet, wait until it is.
          if (!statusSteps) {
            return setTimeout(() => {
              void checkStatus();
            }, IMPORT_SQL_PROGRESS_POLL_INTERVAL);
          }
          jobSteps = statusSteps.map(step => {
            return {
              id: step.name,
              name: (0, _format.capitalize)(step.name?.replace(/_/g, ' ')),
              status: step.result
            };
          });
          if (statusSteps.some(({
            result
          }) => result === 'failed') && !statusSteps.find(({
            name,
            result
          }) => name === 'restore_db' && !result)) {
            jobStatus = 'error';
          } else if (statusSteps.every(({
            result
          }) => result === 'success')) {
            jobStatus = 'success';
            const timestamps = statusSteps.map(step => step.finished_at).filter(Boolean);
            importJob.completedAt = new Date(Math.max(...timestamps, 0) * 1000).toUTCString();
          }
          if (importStatus?.progress?.started_at) {
            importJob.createdAt = new Date(importStatus.progress.started_at * 1000).toUTCString();
          }
          importJob.progress = {
            status: jobStatus,
            steps: jobSteps
          };
        }
      } else if (!importJob) {
        return resolve('No import job found');
      }
      jobStatus = importJob.progress?.status ?? 'unknown';
      jobSteps = importJob.progress?.steps ?? [];
      createdAt = importJob.createdAt;
      completedAt = importJob.completedAt;
      const {
        dbOperationInProgress,
        importInProgress,
        progress: importStepProgress
      } = importStatus ?? {};
      debug({
        jobStatus,
        completedAt,
        createdAt,
        dbOperationInProgress,
        importInProgress,
        importStepProgress
      });
      let jobCreationTime;
      try {
        jobCreationTime = new Date(createdAt ?? '').getTime();
      } catch (err) {
        debug('Unable to parse createdAt to a Date');
      }
      let failedImportStep;
      if (jobCreationTime && (importStepProgress?.started_at ?? 0) * 1000 >= jobCreationTime) {
        // The contents of the `import_progress` meta are pertinent to the most recent import job
        failedImportStep = importStepProgress?.steps?.find(step => step?.result === 'failed' && 1000 * (step.started_at ?? 0) > new Date(createdAt ?? '').getTime());
      }
      if (!jobSteps.length) {
        return reject({
          error: 'Could not enumerate the import job steps',
          launched
        });
      }
      if (failedImportStep) {
        // The server marks the step as a success as per the host action, demote it to 'failed'
        const _jobSteps = [...jobSteps];
        const failedJobStepIndex = _jobSteps.findIndex(step => step?.id === 'import');
        _jobSteps[failedJobStepIndex] = {
          ..._jobSteps[failedJobStepIndex],
          status: 'failed'
        };
        progressTracker.setStepsFromServer(_jobSteps);
        overallStatus = 'failed';
        setSuffixAndPrint();
        return reject({
          inImportProgress: true,
          commandOutput: failedImportStep.output,
          error: 'Import step failed',
          stepName: failedImportStep.name,
          launched
        });
      }
      progressTracker.setStepsFromServer(jobSteps);
      setSuffixAndPrint();
      if (jobStatus === 'error') {
        return reject({
          error: 'Import job failed',
          steps: jobSteps,
          launched
        });
      }
      if (jobStatus !== 'running' && completedAt) {
        return resolve(importJob);
      }
      overallStatus = 'running';
      setTimeout(() => {
        void checkStatus();
      }, IMPORT_SQL_PROGRESS_POLL_INTERVAL);
    };

    // Kick off the check
    void checkStatus();
  });
  try {
    const results = await getResults();
    if (typeof results === 'string') {
      overallStatus = results;
    } else {
      overallStatus = results.progress?.status ?? 'unknown';
      // This shouldn't be 'unknown'...what should we do here?
    }
    progressTracker.stopPrinting();
    setProgressTrackerSuffix();

    // Print one final time
    progressTracker.print({
      clearAfter: true
    });

    // This type of result is not an importing error. e.g. no import job was found
    process.exit(0);
  } catch (importFailed) {
    progressTracker.stopPrinting();
    progressTracker.print({
      clearAfter: true
    });
    exit.withError(getErrorMessage(importFailed, importFailed.launched));
  }
}
var _default = exports.default = {
  importSqlCheckStatus
};