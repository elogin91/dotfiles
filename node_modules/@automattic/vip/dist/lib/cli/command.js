"use strict";

exports.__esModule = true;
exports.containsAppEnvArgument = containsAppEnvArgument;
exports.default = _default;
exports.getEnvIdentifier = getEnvIdentifier;
var _args = _interopRequireDefault(require("args"));
var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _enquirer = require("enquirer");
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _envAlias = require("./envAlias");
var exit = _interopRequireWildcard(require("./exit"));
var _format = require("./format");
var _prompt = require("./prompt");
var _package = _interopRequireDefault(require("../../../package.json"));
var _api = _interopRequireDefault(require("../../lib/api"));
var _app = _interopRequireDefault(require("../../lib/api/app"));
var _tracker = require("../../lib/tracker");
var _userError = _interopRequireDefault(require("../user-error"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function uncaughtError(err) {
  // Error raised when trying to write to an already closed stream
  if (err.code === 'EPIPE') {
    return;
  }
  if (err instanceof _userError.default) {
    exit.withError(err);
  }
  console.log(_chalk.default.red('✕'), 'Please contact VIP Support with the following information:');
  console.log(_chalk.default.dim(err.stack));
  exit.withError('Unexpected error');
}
process.on('uncaughtException', uncaughtError);
process.on('unhandledRejection', uncaughtError);
let _opts = {};
let alreadyConfirmedDebugAttachment = false;

// eslint-disable-next-line complexity
_args.default.argv = async function (argv, cb) {
  if (process.execArgv.includes('--inspect') && !alreadyConfirmedDebugAttachment) {
    await (0, _enquirer.prompt)({
      type: 'confirm',
      name: 'confirm',
      message: "\nAttach the debugger, once you see 'Debugger attached' above hit 'y' to continue"
    });
    alreadyConfirmedDebugAttachment = true;
  }
  const parsedAlias = (0, _envAlias.parseEnvAliasFromArgv)(argv);

  // A usage option allows us to override the default usage text, which isn't
  // accurate for subcommands. By default, it will display something like (note
  // the hyphen):
  //   Usage: vip command-subcommand [options]
  //
  // We can pass "vip command subcommand" to the name param for more accurate
  // usage text:
  //   Usage: vip command subcommand [options]
  //
  // It also allows us to represent required args in usage text:
  //   Usage: vip command subcommand <arg1> <arg2> [options]
  const name = _opts.usage || null;
  const options = this.parse(parsedAlias.argv, {
    help: false,
    name,
    version: false,
    debug: false
  });
  if (options.h || options.help) {
    this.showHelp();
  }
  if (options.v || options.version) {
    this.showVersion();
  }
  if (options.debug || options.d) {
    _debug.default.enable(options.debug === true ? '*' : options.debug);
  }

  // If we have both an --app/--env and an alias, we need to give a warning
  if (parsedAlias.app && (options.app || options.env)) {
    exit.withError('Please only use an environment alias, or the --app and --env parameters, but not both');
  }

  // If there is an alias, use it to populate the app/env options
  if (parsedAlias.app) {
    options.app = parsedAlias.app;
    options.env = parsedAlias.env; // Can be undefined
  }
  const validationError = validateOpts(options);
  if (validationError) {
    const error = validationError.toString();
    await (0, _tracker.trackEvent)('command_validation_error', {
      error
    });
    exit.withError(error);
  }

  // If there's a sub-command, run that instead
  if (this.isDefined(this.sub[0], 'commands')) {
    return {};
  }
  if (process.env.NODE_ENV !== 'test') {
    const {
      default: updateNotifier
    } = await import('update-notifier');
    updateNotifier({
      pkg: _package.default,
      updateCheckInterval: 1000 * 60 * 60 * 24
    }).notify({
      isGlobal: true
    });
  }

  // `help` and `version` are always defined as subcommands
  const customCommands = this.details.commands.filter(command => {
    switch (command.usage) {
      case 'help':
      case 'version':
      case 'debug':
        return false;
      default:
        return true;
    }
  });

  // Show help if no args passed
  if (Boolean(customCommands.length) && !this.sub.length) {
    await (0, _tracker.trackEvent)('command_help_view');
    this.showHelp();
    return {};
  }

  // Show help if required arg is missing
  if (_opts.requiredArgs > this.sub.length) {
    await (0, _tracker.trackEvent)('command_validation_error', {
      error: 'Missing required arg'
    });
    this.showHelp();
    return {};
  }

  // Show help if subcommand is invalid
  const subCommands = this.details.commands.map(cmd => cmd.usage);
  if (!_opts.wildcardCommand && this.sub[_opts.requiredArgs] && 0 > subCommands.indexOf(this.sub[_opts.requiredArgs])) {
    const subcommand = this.sub.join(' ');
    await (0, _tracker.trackEvent)('command_validation_error', {
      error: `Invalid subcommand: ${subcommand}`
    });
    exit.withError(`\`${subcommand}\` is not a valid subcommand. See \`vip --help\``);
  }

  // Set the site in options.app
  let res;
  if (_opts.appContext) {
    // If --app is not set, try to infer the app context
    if (!options.app) {
      const api = (0, _api.default)();
      await (0, _tracker.trackEvent)('command_appcontext_list_fetch');
      try {
        res = await api.query({
          query: (0, _graphqlTag.default)`query Apps( $first: Int, $after: String ) {
							apps( first: $first, after: $after ) {
								total
								nextCursor
								edges {
									${_opts.appQuery}
								}
							}
						}
						${_opts.appQueryFragments || ''}`,
          variables: {
            first: 100,
            after: null // TODO make dynamic?
          }
        });
      } catch (err) {
        const message = err.toString();
        await (0, _tracker.trackEvent)('command_appcontext_list_fetch_error', {
          error: message
        });
        exit.withError(`Failed to get app (${_opts.appQuery}) details: ${message}`);
      }
      if (!res.data?.apps?.edges?.length) {
        await (0, _tracker.trackEvent)('command_appcontext_list_fetch_error', {
          error: 'No apps found'
        });
        exit.withError("Couldn't find any apps");
      }
      const appNames = res.data.apps.edges.map(cur => cur.name);
      let appSelection;
      try {
        appSelection = await (0, _enquirer.prompt)({
          type: 'autocomplete',
          name: 'app',
          message: 'Which app?',
          limit: 10,
          choices: appNames
        });
      } catch (err) {
        if (!err) {
          process.exit();
        }
        exit.withError(err.message || err);
      }

      // Copy all app information
      appSelection.app = res.data.apps.edges.find(cur => cur.name === appSelection.app);
      if (!appSelection.app?.id) {
        await (0, _tracker.trackEvent)('command_appcontext_list_select_error', {
          error: 'Invalid app selected'
        });
        exit.withError(`App ${_chalk.default.blueBright(appSelection.app.name)} does not exist`);
      }
      await (0, _tracker.trackEvent)('command_appcontext_list_select_success');
      options.app = {
        ...appSelection.app
      };
    } else {
      let appLookup;
      try {
        appLookup = await (0, _app.default)(options.app, _opts.appQuery, _opts.appQueryFragments);
      } catch (err) {
        await (0, _tracker.trackEvent)('command_appcontext_param_error', {
          error: 'App lookup failed'
        });
        exit.withError(`App ${_chalk.default.blueBright(options.app)} does not exist`);
      }
      if (!appLookup?.id) {
        await (0, _tracker.trackEvent)('command_appcontext_param_error', {
          error: 'Invalid app specified'
        });
        exit.withError(`App ${_chalk.default.blueBright(options.app)} does not exist`);
      }
      await (0, _tracker.trackEvent)('command_appcontext_param_select');
      options.app = {
        ...appLookup
      };
    }
    if (_opts.childEnvContext) {
      options.app.environments = options.app.environments.filter(cur => cur.id !== options.app.id);
    }
  }
  if ((_opts.envContext || _opts.childEnvContext) && options.app) {
    if (options.env) {
      if (_opts.childEnvContext && options.env.toLowerCase() === 'production') {
        await (0, _tracker.trackEvent)('command_childcontext_param_error', {
          error: 'Cannot use `production`'
        });
        exit.withError('Environment production is not allowed for this command');
      }
      const env = options.app.environments.find(cur => getEnvIdentifier(cur).toLowerCase() === options.env.toLowerCase());
      if (!env) {
        await (0, _tracker.trackEvent)('command_childcontext_param_error', {
          error: `Invalid child environment (${options.env}) specified`
        });
        exit.withError(`Environment ${_chalk.default.blueBright(options.env)} for app ${_chalk.default.blueBright(options.app.name)} does not exist`);
      }
      options.env = env;
    } else if (!options.app?.environments?.length) {
      console.log('To set up a new development environment, please contact VIP Support.');
      await (0, _tracker.trackEvent)('command_childcontext_fetch_error', {
        error: 'No child environments found'
      });
      exit.withError(`Could not find any non-production environments for ${_chalk.default.blueBright(options.app.name)}.`);
    } else if (options.app.environments.length === 1) {
      options.env = options.app.environments[0];
    } else if (options.app.environments.length > 1) {
      const environmentNames = options.app.environments.map(envObject => getEnvIdentifier(envObject));
      let envSelection;
      try {
        envSelection = await (0, _enquirer.prompt)({
          type: 'select',
          name: 'env',
          message: 'Which environment?',
          choices: environmentNames
        });
      } catch (err) {
        if (!err) {
          process.exit();
        }
        exit.withError(err.message || err);
      }

      // Get full environment info after user selection
      envSelection.env = options.app.environments.find(envObject => getEnvIdentifier(envObject) === envSelection.env);
      if (!envSelection.env?.id) {
        await (0, _tracker.trackEvent)('command_childcontext_list_select_error', {
          error: 'Invalid environment selected'
        });
        exit.withError(`Environment ${_chalk.default.blueBright(getEnvIdentifier(envSelection.env))} does not exist`);
      }
      await (0, _tracker.trackEvent)('command_childcontext_list_select_success');
      options.env = envSelection.env;
    }
  }

  // Prompt for confirmation if necessary
  if (_opts.requireConfirm && !options.force) {
    /** @type {Tuple[]} */
    const info = [];
    if (options.app) {
      info.push({
        key: 'App',
        value: `${options.app.name} (id: ${options.app.id})`
      });
    }
    if (options.env) {
      const envName = getEnvIdentifier(options.env);
      info.push({
        key: 'Environment',
        value: `${envName} (id: ${options.env.id})`
      });
    }
    let message = 'Are you sure?';
    if ('string' === typeof _opts.requireConfirm) {
      message = _opts.requireConfirm;
    }
    switch (_opts.module) {
      case 'import-sql':
        {
          const site = options.env;
          if (site?.primaryDomain) {
            const primaryDomainName = site.primaryDomain.name;
            info.push({
              key: 'Primary Domain Name',
              value: primaryDomainName
            });
          }

          // Site launched details
          const haveLaunchedField = Object.hasOwn(site, 'launched');
          if (haveLaunchedField) {
            const launched = site.launched ? '✅ Yes' : `${_chalk.default.red('x')} No`;
            info.push({
              key: 'Launched?',
              value: `${_chalk.default.cyan(launched)}`
            });
          }
          if (this.sub) {
            info.push({
              key: 'SQL File',
              value: `${_chalk.default.blueBright(this.sub)}`
            });
          }
          options.skipValidate = Object.hasOwn(options, 'skipValidate') && Boolean(options.skipValidate) && !['false', 'no'].includes(options.skipValidate);
          if (options.skipValidate) {
            info.push({
              key: 'Pre-Upload Validations',
              value: _chalk.default.red('SKIPPED!')
            });
          }

          // Show S-R params if the `search-replace` flag is set
          const searchReplace = options.searchReplace;
          const assignSRValues = (from, to) => {
            const pairs = {
              From: `${from}`,
              To: `${to}`
            };
            return pairs;
          };
          if (searchReplace) {
            const searchReplaceValues = (0, _format.formatSearchReplaceValues)(searchReplace, assignSRValues);

            // Format data into a user-friendly table
            info.push({
              key: 'Replacements',
              value: '\n' + (0, _format.formatData)(searchReplaceValues, 'table')
            });
          }
          break;
        }
      case 'sync':
        {
          const {
            backup,
            canSync,
            errors
          } = options.env.syncPreview;
          if (!canSync) {
            // User can not sync due to some error(s)
            // Shows the first error in the array
            exit.withError(`Could not sync to this environment: ${errors[0].message}`);
          }

          // remove __typename from replacements.
          // can not be deleted afterwards if deconstructed
          const replacements = options.env.syncPreview.replacements.map(rep => {
            const {
              from,
              to
            } = rep;
            return {
              from,
              to
            };
          });
          if (backup) {
            info.push({
              key: 'From backup',
              value: new Date(backup.createdAt).toUTCString()
            });
          }
          info.push({
            key: 'Replacements',
            value: '\n' + (0, _format.formatData)(replacements, 'table')
          });
          break;
        }
      case 'import-media':
        info.push({
          key: 'Archive URL',
          value: _chalk.default.blue.underline(this.sub)
        });
        options.overwriteExistingFiles = Object.hasOwn(options, 'overwriteExistingFiles') && Boolean(options.overwriteExistingFiles) && !['false', 'no'].includes(options.overwriteExistingFiles);
        info.push({
          key: 'Overwrite any existing files',
          value: options.overwriteExistingFiles ? '✅ Yes' : `${_chalk.default.red('x')} No`
        });
        options.importIntermediateImages = Object.hasOwn(options, 'importIntermediateImages') && Boolean(options.importIntermediateImages) && !['false', 'no'].includes(options.importIntermediateImages);
        info.push({
          key: 'Import intermediate image files',
          value: options.importIntermediateImages ? '✅ Yes' : `${_chalk.default.red('x')} No`
        });
        options.exportFileErrorsToJson = Object.hasOwn(options, 'exportFileErrorsToJson') && Boolean(options.exportFileErrorsToJson) && !['false', 'no'].includes(options.exportFileErrorsToJson);
        info.push({
          key: 'Export any file errors encountered to a JSON file instead of a plain text file.',
          value: options.exportFileErrorsToJson ? '✅ Yes' : `${_chalk.default.red('x')} No`
        });
        break;
      default:
    }
    const skipPrompt = _opts.skipConfirmPrompt || false;
    const yes = await (0, _prompt.confirm)(info, message, skipPrompt);
    if (!yes) {
      await (0, _tracker.trackEvent)('command_confirm_cancel');
      return {};
    }
    await (0, _tracker.trackEvent)('command_confirm_success');
  }
  if (cb) {
    res = await cb(this.sub, options);
    if (_opts.format && res) {
      if (res.header) {
        if (options.format !== 'json') {
          console.log((0, _format.formatData)(res.header, 'keyValue'));
        }
        res = res.data;
      }
      res = res.map(row => {
        const out = {
          ...row
        };
        if (out.__typename) {
          // Apollo injects __typename
          delete out.__typename;
        }
        return out;
      });
      await (0, _tracker.trackEvent)('command_output', {
        format: options.format
      });
      const formattedOut = (0, _format.formatData)(res, options.format);
      console.log(formattedOut);
      return {};
    }
  }
  return options;
};

/**
 * @returns {Error|undefined}
 */
function validateOpts(opts) {
  if (opts.app) {
    if (typeof opts.app !== 'string' && typeof opts.app !== 'number') {
      return new Error('Invalid --app');
    }
    if (opts.app.length < 1) {
      return new Error('Invalid --app');
    }
  }
  if (opts.env) {
    if (typeof opts.env !== 'string' && typeof opts.env !== 'number') {
      return new Error('Invalid --env');
    }
    if (opts.env.length < 1) {
      return new Error('Invalid --env');
    }
  }
}

/**
 * @returns {args}
 */
function _default(opts) {
  _opts = {
    appContext: false,
    appQuery: 'id,name',
    childEnvContext: false,
    envContext: false,
    format: false,
    requireConfirm: false,
    requiredArgs: 0,
    wildcardCommand: false,
    ...opts
  };
  if (_opts.appContext || _opts.requireConfirm) {
    _args.default.option('app', 'Target an application. Accepts a string value for the application name or an integer for the application ID.');
  }
  if (_opts.envContext || _opts.childEnvContext) {
    _args.default.option('env', 'Target an environment. Accepts a string value for the environment type.');
  }
  if (_opts.requireConfirm) {
    _args.default.option('force', 'Skip confirmation.', false);
  }
  if (_opts.format) {
    _args.default.option('format', 'Render output in a particular format. Accepts "table" (default), "csv", and "json".', 'table');
  }

  // Add help and version to all subcommands
  _args.default.option('help', 'Retrieve a description, examples, and available options for a (sub)command.');
  _args.default.option('version', 'Retrieve the version number of VIP-CLI currently installed on the local machine.');
  _args.default.option('debug', 'Generate verbose output during command execution to help identify or fix errors or bugs.');
  return _args.default;
}
function getEnvIdentifier(env) {
  let identifier = env.type;

  // If the env has a unique name (happens when site has multiple envs of a type), add on name
  // for disambiguation. Only on non-main-env
  if (env.name !== env.type && env.name && env.appId !== env.id) {
    identifier = `${identifier}.${env.name}`;
  }
  return identifier;
}
function containsAppEnvArgument(argv) {
  const parsedAlias = (0, _envAlias.parseEnvAliasFromArgv)(argv);
  return Boolean(parsedAlias.app || parsedAlias.env || argv.includes('--app') || argv.includes('--env'));
}