"use strict";

exports.__esModule = true;
exports.StepStatus = exports.ProgressTracker = void 0;
var _nodeOs = require("node:os");
var _singleLineLog = require("single-line-log");
var _format = require("../../lib/cli/format");
const PRINT_INTERVAL = process.env.DEBUG ? 5000 : 200; // How often the report is printed. Mainly affects the "spinner" animation.
let StepStatus = exports.StepStatus = /*#__PURE__*/function (StepStatus) {
  StepStatus["PENDING"] = "pending";
  StepStatus["RUNNING"] = "running";
  StepStatus["SUCCESS"] = "success";
  StepStatus["FAILED"] = "failed";
  StepStatus["UNKNOWN"] = "unknown";
  StepStatus["SKIPPED"] = "skipped";
  return StepStatus;
}({});
const COMPLETED_STEP_SLUGS = [StepStatus.SUCCESS, StepStatus.SKIPPED];
class ProgressTracker {
  hasFailure;
  hasPrinted;
  printInterval;

  // Track the state of each step
  stepsFromCaller;
  stepsFromServer;

  // Spinnerz go brrrr
  runningSprite;

  // This gets printed before the step status
  prefix;

  // This gets printed after the step status
  suffix;

  /**
   * This determines from which step should we display the steps
   *
   * Useful when you want to display a prompt.
   *
   * And we don't want to repeatedly display the steps that has finished.
   */
  displayFromStep = 0;
  constructor(steps) {
    this.runningSprite = new _format.RunningSprite();
    this.hasFailure = false;
    this.hasPrinted = false;
    this.stepsFromCaller = this.mapSteps(steps);
    this.stepsFromServer = new Map();
    this.prefix = '';
    this.suffix = '';
  }
  getSteps() {
    return new Map([...this.stepsFromCaller, ...this.stepsFromServer]);
  }
  mapSteps(steps) {
    return steps.reduce((map, {
      id,
      name,
      status
    }) => {
      map.set(id, {
        id,
        name,
        status: status ?? StepStatus.PENDING
      });
      return map;
    }, new Map());
  }
  setUploadPercentage(percentage) {
    const uploadStep = this.stepsFromCaller.get('upload');
    if (!uploadStep) {
      return;
    }
    this.stepsFromCaller.set('upload', {
      ...uploadStep,
      percentage
    });
  }
  setProgress(progress) {
    const step = this.getCurrentStep();
    if (!step) {
      return;
    }
    this.stepsFromCaller.set(step.id, {
      ...step,
      progress
    });
  }
  setStepsFromServer(steps) {
    const formattedSteps = steps.map(({
      name,
      status
    }, index) => ({
      id: `server-${index}-${name}`,
      name,
      status
    }));
    if (!steps.some(({
      status
    }) => status === StepStatus.RUNNING)) {
      const firstPendingStepIndex = steps.findIndex(({
        status
      }) => status === StepStatus.PENDING);
      if (firstPendingStepIndex !== -1) {
        // "Promote" the first "pending" to "running"
        formattedSteps[firstPendingStepIndex].status = StepStatus.RUNNING;
      }
    }
    this.stepsFromServer = this.mapSteps(formattedSteps);
  }
  getNextStep() {
    if (this.allStepsSucceeded()) {
      return undefined;
    }
    const steps = [...this.getSteps().values()];
    return steps.find(({
      status
    }) => status === StepStatus.PENDING);
  }
  getCurrentStep() {
    if (this.allStepsSucceeded()) {
      return undefined;
    }
    const steps = [...this.getSteps().values()];
    return steps.find(({
      status
    }) => status === StepStatus.RUNNING);
  }
  stepRunning(stepId) {
    this.setStatusForStepId(stepId, StepStatus.RUNNING);
  }
  stepFailed(stepId) {
    this.setStatusForStepId(stepId, StepStatus.FAILED);
  }
  stepSkipped(stepId) {
    this.setStatusForStepId(stepId, StepStatus.SKIPPED);
  }
  stepSuccess(stepId) {
    this.setStatusForStepId(stepId, StepStatus.SUCCESS);
    // The stepSuccess helper automatically sets the next step to "running"
    const nextStep = this.getNextStep();
    if (nextStep) {
      this.stepRunning(nextStep.id);
    }
  }
  allStepsSucceeded() {
    return [...this.getSteps().values()].every(({
      status
    }) => status === StepStatus.SUCCESS);
  }
  setStatusForStepId(stepId, status) {
    const step = this.stepsFromCaller.get(stepId);
    if (!step) {
      // Only allowed to update existing steps with this method
      throw new Error(`Step name ${stepId} is not valid.`);
    }
    if (COMPLETED_STEP_SLUGS.includes(step.status)) {
      throw new Error(`Step name ${stepId} is already completed.`);
    }
    if (status === StepStatus.FAILED) {
      this.hasFailure = true;
    }
    this.stepsFromCaller.set(stepId, {
      ...step,
      status
    });
  }
  startPrinting(prePrintCallback = () => {}) {
    this.printInterval = setInterval(() => {
      prePrintCallback();
      this.print();
    }, PRINT_INTERVAL);
  }
  stopPrinting() {
    if (this.printInterval) {
      clearInterval(this.printInterval);
    }
  }
  async handleContinuePrompt(prompt) {
    this.print();
    this.stopPrinting();
    let isPromptShown = false;
    const setPromptShown = () => {
      isPromptShown = true;
    };
    const returnValue = await prompt(setPromptShown);
    if (isPromptShown) {
      this.displayFromStep = [...this.getSteps().values()].findIndex(step => step.status === StepStatus.RUNNING);
    }
    let hasPrintedOnce = false;
    const printingStartedPromise = new Promise(resolve => {
      this.startPrinting(() => {
        if (hasPrintedOnce) {
          return;
        }

        // this is so that we leave some room for the progress tracker to refresh
        // without this, any prompt, or any text in between will get overwritten by the progress tracker
        let linesToSkip = '';
        for (let iteration = 0; iteration < this.stepsFromCaller.size; iteration++) {
          linesToSkip += _nodeOs.EOL;
        }
        if (isPromptShown) {
          process.stdout.write(linesToSkip);
        }
        hasPrintedOnce = true;
        resolve();
      });
    });
    await printingStartedPromise;
    return returnValue;
  }
  print({
    clearAfter = false
  } = {}) {
    if (!this.hasPrinted) {
      this.hasPrinted = true;
      _singleLineLog.stdout.clear();
    }
    const stepValues = [...this.getSteps().values()];
    const logs = stepValues.reduce((accumulator, {
      name,
      id,
      percentage,
      status,
      progress
    }, stepNumber) => {
      if (stepNumber < this.displayFromStep) {
        return accumulator;
      }
      const statusIcon = (0, _format.getGlyphForStatus)(status, this.runningSprite);
      let suffix = '';
      if (id === 'upload') {
        if (status === StepStatus.RUNNING && percentage) {
          suffix = percentage;
        }
      } else if (progress) {
        suffix = progress;
      }
      return `${accumulator}${statusIcon} ${name} ${suffix}\n`;
    }, '');

    // Output the logs
    (0, _singleLineLog.stdout)(`${this.prefix || ''}${logs}${this.suffix || ''}`);
    if (clearAfter) {
      // Break out of the "Single log line" buffer
      _singleLineLog.stdout.clear();
    }
  }
}
exports.ProgressTracker = ProgressTracker;