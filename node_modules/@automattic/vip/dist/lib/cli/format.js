"use strict";

exports.__esModule = true;
exports.RunningSprite = exports.RUNNING_SPRITE_GLYPHS = void 0;
exports.capitalize = capitalize;
exports.formatBytes = void 0;
exports.formatData = formatData;
exports.formatDuration = formatDuration;
exports.formatEnvironment = formatEnvironment;
exports.formatMetricBytes = void 0;
exports.formatSearchReplaceValues = formatSearchReplaceValues;
exports.getGlyphForStatus = getGlyphForStatus;
exports.isJson = isJson;
exports.isJsonObject = isJsonObject;
exports.keyValue = keyValue;
exports.requoteArgs = requoteArgs;
exports.table = table;
var _plainjs = require("@json2csv/plainjs");
var _chalk = _interopRequireDefault(require("chalk"));
var _cliTable = _interopRequireDefault(require("cli-table3"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function formatData(data, format) {
  if (!data.length) {
    return '';
  }
  switch (format) {
    case 'ids':
      return ids(data);
    case 'json':
      return JSON.stringify(data, null, '\t');
    case 'csv':
      return csv(data);
    case 'keyValue':
      return keyValue(data);
    case 'table':
    default:
      return table(data);
  }
}
function formatEnvironment(environment) {
  if ('production' === environment.toLowerCase()) {
    return _chalk.default.red(environment.toUpperCase());
  }
  return _chalk.default.blueBright(environment.toLowerCase());
}
function ids(data) {
  const fields = Object.keys(data[0]).map(key => key.toLowerCase());
  if (0 > fields.indexOf('id')) {
    return 'No ID field found';
  }
  const id = data.map(datum => datum.id);
  return id.join(' ');
}
function csv(data) {
  const fields = Object.keys(data[0]);
  const parser = new _plainjs.Parser({
    formatters: {
      header: value => {
        return `"${value.split(/(?=[A-Z])/).join(' ').toLowerCase()}"`;
      }
    },
    fields
  });
  return parser.parse(data);
}
function table(data) {
  const fields = Object.keys(data[0]);
  const dataTable = new _cliTable.default({
    head: formatFields(fields),
    style: {
      head: ['brightBlue']
    }
  });
  data.forEach(datum => {
    const row = fields.map(field => datum[field].toString());
    dataTable.push(row);
  });
  return dataTable.toString();
}
function formatFields(fields) {
  return fields.map(field => {
    return field.split(/(?=[A-Z])/).join(' ').toLowerCase();
  });
}
function keyValue(values) {
  const lines = [];
  const pairs = values.length > 0;
  if (pairs) {
    lines.push('===================================');
  }
  for (const {
    key,
    value
  } of values) {
    let formattedValue;
    switch (key.toLowerCase() // NOSONAR
    ) {
      case 'environment':
        formattedValue = formatEnvironment(value);
        break;
      default:
        formattedValue = value;
        break;
    }
    lines.push(`+ ${key}: ${formattedValue}`);
  }
  lines.push('===================================');
  return lines.join('\n');
}
function requoteArgs(args) {
  return args.map(arg => {
    if (arg.includes('--') && arg.includes('=') && arg.includes(' ')) {
      return arg.replace(/"/g, '\\"').replace(/^--([^=]*)=(.*)$/, '--$1="$2"');
    }
    if (arg.includes(' ') && !isJsonObject(arg)) {
      return `"${arg.replace(/"/g, '\\"')}"`;
    }
    return arg;
  });
}
function isJsonObject(str) {
  return typeof str === 'string' && str.trim().startsWith('{') && isJson(str);
}
function isJson(str) {
  try {
    JSON.parse(str);
    return true;
  } catch (error) {
    return false;
  }
}
function capitalize(str) {
  if (typeof str !== 'string' || !str.length) {
    return '';
  }
  return str[0].toUpperCase() + str.slice(1);
}
const RUNNING_SPRITE_GLYPHS = exports.RUNNING_SPRITE_GLYPHS = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
class RunningSprite {
  count;
  constructor() {
    this.count = 0;
  }
  next() {
    if (++this.count >= RUNNING_SPRITE_GLYPHS.length) {
      this.count = 0;
    }
  }
  toString() {
    const glyph = RUNNING_SPRITE_GLYPHS[this.count];
    this.next(); // TODO: throttle
    return glyph;
  }
}
exports.RunningSprite = RunningSprite;
function getGlyphForStatus(status, runningSprite) {
  switch (status) {
    case 'pending':
      return '○';
    case 'running':
      return _chalk.default.blueBright(runningSprite);
    case 'success':
      return _chalk.default.green('✓');
    case 'failed':
      return _chalk.default.red('✕');
    case 'unknown':
      return _chalk.default.yellow('✕');
    case 'skipped':
      return _chalk.default.green('-');
    default:
      return '';
  }
}

// Format Search and Replace values to output
function formatSearchReplaceValues(values, message) {
  // Convert single pair S-R values to arrays
  const searchReplaceValues = typeof values === 'string' ? [values] : values;
  return searchReplaceValues.map(pairs => {
    // Turn each S-R pair into its own array, then trim away whitespace
    const [from, to] = pairs.split(',').map(pair => pair.trim());
    return message(from, to);
  });
}

// Format bytes into kilobytes, megabytes, etc based on the size
// for historical reasons, this uses KB instead of KiB, MB instead of MiB and so on.
const formatBytes = (bytes, decimals = 2, bytesMultiplier = 1024, sizes = ['bytes', 'KB', 'MB', 'GB', 'TB']) => {
  if (0 === bytes) {
    return '0 Bytes';
  }
  const dm = decimals < 0 ? 0 : decimals;
  const idx = Math.floor(Math.log(bytes) / Math.log(bytesMultiplier));
  return `${parseFloat((bytes / Math.pow(bytesMultiplier, idx)).toFixed(dm))} ${sizes[idx]}`;
};

/**
 * Format bytes in powers of 1000, based on the size
 * This is how it's displayed on Macs
 */
exports.formatBytes = formatBytes;
const formatMetricBytes = (bytes, decimals = 2) => {
  return formatBytes(bytes, decimals, 1000);
};

/*
 * Get the duration between two dates
 *
 * @param {Date} from The start date
 * @param {Date} to  The end date
 * @returns {string} The duration between the two dates
 */
exports.formatMetricBytes = formatMetricBytes;
function formatDuration(from, to) {
  const millisecondsPerSecond = 1000;
  const millisecondsPerMinute = 60 * millisecondsPerSecond;
  const millisecondsPerHour = 60 * millisecondsPerMinute;
  const millisecondsPerDay = 24 * millisecondsPerHour;
  const duration = to.getTime() - from.getTime();
  if (duration < 1000) return '0 second';
  const days = Math.floor(duration / millisecondsPerDay);
  const hours = Math.floor(duration % millisecondsPerDay / millisecondsPerHour);
  const minutes = Math.floor(duration % millisecondsPerHour / millisecondsPerMinute);
  const seconds = Math.floor(duration % millisecondsPerMinute / millisecondsPerSecond);
  let durationString = '';
  if (days > 0) {
    durationString += `${days} day${days > 1 ? 's' : ''} `;
  }
  if (hours > 0) {
    durationString += `${hours} hour${hours > 1 ? 's' : ''} `;
  }
  if (minutes > 0) {
    durationString += `${minutes} minute${minutes > 1 ? 's' : ''} `;
  }
  if (seconds > 0) {
    durationString += `${seconds} second${seconds > 1 ? 's' : ''}`;
  }
  return durationString.trim();
}