"use strict";

exports.__esModule = true;
exports.validate = exports.staticSqlValidations = exports.getTableNames = void 0;
exports.validateFilename = validateFilename;
exports.validateImportFileExtension = void 0;
var _chalk = _interopRequireDefault(require("chalk"));
var _path = _interopRequireDefault(require("path"));
var _singleLineLog = require("single-line-log");
var exit = _interopRequireWildcard(require("../../lib/cli/exit"));
var _clientFileUploader = require("../../lib/client-file-uploader");
var _tracker = require("../../lib/tracker");
var _lineByLine = require("../../lib/validations/line-by-line");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
let problemsFound = 0;
let lineNum = 1;
const tableNames = [];
function formatError(message) {
  return `${_chalk.default.red('SQL Error:')} ${message}`;
}
function formatWarning(message) {
  return `${_chalk.default.yellow('Warning:')} ${message}`;
}
function formatRecommendation(message) {
  return `${_chalk.default.yellow('Recommendation:')} ${message}`;
}
/**
 * Check if a file has a valid extension
 *
 * @param {string} filename The file extension
 * @returns {boolean} True if the extension is valid
 */
const validateImportFileExtension = filename => {
  const ext = _path.default.extname(filename).toLowerCase();
  if (!['.sql', '.gz'].includes(ext)) {
    exit.withError('Invalid file extension. Please provide a .sql or .gz file.');
  }
};
exports.validateImportFileExtension = validateImportFileExtension;
function validateFilename(filename) {
  const re = /^[a-z0-9\-_.]+$/i;

  // Exits if filename contains anything outside a-z A-Z - _ .
  if (!re.test(filename)) {
    exit.withError('Error: The characters used in the name of a file for import are limited to [0-9,a-z,A-Z,-,_,.]');
  }
}
const generalCheckFormatter = check => {
  const errors = [];
  const infos = [];
  const validProblems = check.results.filter(result => !result.falsePositive);
  if (validProblems.length > 0) {
    if (validProblems.some(result => !result.warning)) {
      problemsFound += 1;
    }
    for (const problem of validProblems) {
      const text = `${problem.text ?? check.message} on line ${problem.lineNumber ?? ''}.`;
      if (problem.warning) {
        errors.push({
          warning: formatWarning(text),
          recommendation: formatRecommendation(problem.recomendation ?? check.recommendation)
        });
      } else {
        errors.push({
          error: formatError(text),
          recommendation: formatRecommendation(problem.recomendation ?? check.recommendation)
        });
      }
    }
  } else {
    infos.push(`✅ ${check.message} was found 0 times.`);
  }
  return {
    errors,
    infos
  };
};
const lineNumberCheckFormatter = check => {
  const errors = [];
  const infos = [];
  if (check.results.length > 0) {
    problemsFound += 1;
    const lineNumbers = check.results.map(result => result.lineNumber);
    errors.push({
      error: formatError(`${check.message} on line(s) ${lineNumbers.join(', ')}.`),
      recommendation: formatRecommendation(check.recommendation)
    });
  } else {
    infos.push(`✅ ${check.message} was found 0 times.`);
  }
  return {
    errors,
    infos
  };
};
const requiredCheckFormatter = (check, type, isImport) => {
  const errors = [];
  const infos = [];
  if (check.results.length > 0) {
    infos.push(`✅ ${check.message} was found ${check.results.length} times.`);
    if (type === 'createTable') {
      if (!isImport) {
        checkTablePrefixes(check.results, errors, infos);
      }
    }
  } else {
    problemsFound += 1;
    errors.push({
      error: formatError(`${check.message} was not found.`),
      recommendation: formatRecommendation(check.recommendation)
    });
  }
  return {
    errors,
    infos
  };
};
const infoCheckFormatter = check => {
  const infos = [];
  check.results.forEach(item => {
    if (item.text) {
      infos.push(item.text);
    }
  });
  return {
    errors: [],
    infos
  };
};
function checkTablePrefixes(results, errors, infos) {
  const wpTables = [];
  const notWPTables = [];
  const wpMultisiteTables = [];
  results.forEach(result => {
    const tableName = result.text ?? '';
    if (/^wp_(\d+_)/.exec(tableName)) {
      wpMultisiteTables.push(tableName);
    } else if (tableName.startsWith('wp_')) {
      wpTables.push(tableName);
    } else {
      notWPTables.push(tableName);
    }
  });
  if (wpTables.length > 0) {
    infos.push(` - wp_ prefix tables found: ${wpTables.length} `);
  }
  if (notWPTables.length > 0) {
    problemsFound += 1;
    errors.push({
      error: formatError(`tables without wp_ prefix found: ${notWPTables.join(',')}`),
      recommendation: formatRecommendation('Please make sure all table names are prefixed with `wp_`')
    });
  }
  if (wpMultisiteTables.length > 0) {
    infos.push(` - wp_n_ prefix tables found: ${wpMultisiteTables.length} `);
  }
}
const checks = {
  binaryLogging: {
    matcher: /SET @@SESSION.sql_log_bin/i,
    matchHandler: lineNumber => ({
      lineNumber
    }),
    outputFormatter: lineNumberCheckFormatter,
    results: [],
    message: 'SET @@SESSION.sql_log_bin statement',
    excerpt: "'SET @@SESSION.sql_log_bin' statement should not be present (case-insensitive)",
    recommendation: 'Remove these lines'
  },
  trigger: {
    // Match `CREATE (DEFINER=`root`@`host`) TRIGGER`
    // eslint-disable-next-line security/detect-unsafe-regex
    matcher: /^CREATE (\(?DEFINER=`?(\w*)(`@`)?(\w*\.*%?)*`?\)?)?(| )TRIGGER/i,
    matchHandler: lineNumber => ({
      lineNumber
    }),
    outputFormatter: lineNumberCheckFormatter,
    results: [],
    message: 'TRIGGER statement',
    excerpt: "'TRIGGER' statement should not be present (case-sensitive)",
    recommendation: 'Remove these lines'
  },
  dropDB: {
    matcher: /^DROP DATABASE/i,
    matchHandler: lineNumber => ({
      lineNumber
    }),
    outputFormatter: lineNumberCheckFormatter,
    results: [],
    message: 'DROP DATABASE statement',
    excerpt: "'DROP DATABASE' should not be present (case-insensitive)",
    recommendation: 'Remove these lines'
  },
  useStatement: {
    matcher: /^USE /i,
    matchHandler: lineNumber => ({
      lineNumber
    }),
    outputFormatter: lineNumberCheckFormatter,
    results: [],
    message: 'USE <DATABASE_NAME> statement',
    excerpt: "'USE <DATABASE_NAME>' should not be present (case-insensitive)",
    recommendation: 'Remove these lines'
  },
  alterUser: {
    matcher: /^(ALTER USER|SET PASSWORD)/i,
    matchHandler: lineNumber => ({
      lineNumber
    }),
    outputFormatter: lineNumberCheckFormatter,
    results: [],
    message: 'ALTER USER statement',
    excerpt: "'ALTER USER' should not be present (case-insensitive)",
    recommendation: 'Remove these lines'
  },
  dropTable: {
    matcher: /^DROP TABLE IF EXISTS `?([a-z0-9_]*)/i,
    matchHandler: (lineNumber, results) => ({
      text: results[1]
    }),
    outputFormatter: requiredCheckFormatter,
    results: [],
    message: 'DROP TABLE',
    excerpt: "'DROP TABLE IF EXISTS' should be present (case-insensitive)",
    recommendation: 'Check import settings to include DROP TABLE statements'
  },
  createTable: {
    matcher: /^CREATE TABLE (?:IF NOT EXISTS )?`?([a-z0-9_]*)/i,
    matchHandler: (lineNumber, results) => ({
      text: results[1]
    }),
    outputFormatter: requiredCheckFormatter,
    results: [],
    message: 'CREATE TABLE',
    excerpt: "'CREATE TABLE' should be present (case-insensitive)",
    recommendation: 'Check import settings to include CREATE TABLE statements'
  },
  alterTable: {
    matcher: /^ALTER TABLE `?([a-z0-9_]*)/i,
    matchHandler: lineNumber => ({
      lineNumber
    }),
    outputFormatter: lineNumberCheckFormatter,
    results: [],
    message: 'ALTER TABLE statement',
    excerpt: "'ALTER TABLE' should not be present (case-insensitive)",
    recommendation: 'Remove these lines and define table structure in the CREATE TABLE statement instead'
  },
  uniqueChecks: {
    matcher: /^SET UNIQUE_CHECKS\s*=\s*0/i,
    matchHandler: lineNumber => ({
      lineNumber
    }),
    outputFormatter: lineNumberCheckFormatter,
    results: [],
    message: 'SET UNIQUE_CHECKS = 0',
    excerpt: "'SET UNIQUE_CHECKS = 0' should not be present",
    recommendation: "Disabling 'UNIQUE_CHECKS' is not allowed. These lines should be removed"
  },
  siteHomeUrl: {
    matcher: `['"](siteurl|home)['"],\\s?['"](.*?)['"]`,
    matchHandler: (lineNumber, results) => ({
      text: results[1] + ' ' + results[2]
    }),
    outputFormatter: infoCheckFormatter,
    results: [],
    message: 'Siteurl/home matches',
    excerpt: 'Siteurl/home options',
    recommendation: ''
  },
  siteHomeUrlLando: {
    matcher: `['"](siteurl|home)['"],\\s?['"]([^'"]+)['"]`,
    matchHandler: (lineNumber, results, expectedDomain) => {
      let foundDomain = results[2];
      if (!/^https?:\/\//i.test(foundDomain)) {
        return {
          falsePositive: true
        };
      }
      foundDomain = foundDomain.replace(/^https?:\/\//, '');
      if (!foundDomain.trim()) {
        return {
          falsePositive: true
        };
      }
      if (foundDomain.includes(expectedDomain)) {
        return {
          falsePositive: true
        };
      }
      return {
        warning: true,
        lineNumber,
        recomendation: `Use '--search-replace="${foundDomain},${expectedDomain}"' switch to replace the domain`
      };
    },
    outputFormatter: generalCheckFormatter,
    results: [],
    message: 'Siteurl/home options not pointing to lando domain',
    excerpt: 'Siteurl/home options not pointing to lando domain',
    recommendation: "Use search-replace to change environment's domain"
  },
  engineInnoDB: {
    matcher: /\sENGINE\s?=(?!(\s?InnoDB))/i,
    matchHandler: lineNumber => ({
      lineNumber
    }),
    outputFormatter: lineNumberCheckFormatter,
    results: [],
    message: 'ENGINE != InnoDB',
    excerpt: "'ENGINE=InnoDB' should be present (case-insensitive) for all tables",
    recommendation: "Ensure your application works with InnoDB and update your SQL dump to include only 'ENGINE=InnoDB' engine definitions in 'CREATE TABLE' statements. " + "We suggest you search for all 'ENGINE=X' entries and replace them with 'ENGINE=InnoDB'!"
  }
};
const DEV_ENV_SPECIFIC_CHECKS = ['useStatement', 'siteHomeUrlLando'];
function findDuplicates(arr, where) {
  const filtered = arr.filter(item => {
    if (where.has(item)) {
      where.delete(item);
      return false;
    }
    return true;
  });
  return [...new Set(filtered)];
}
const postValidation = async options => {
  await (0, _tracker.trackEvent)('import_validate_sql_command_execute', {
    is_import: options.isImport
  });
  if (!options.isImport) {
    (0, _singleLineLog.stdout)(`Finished processing ${lineNum} lines.`);
    console.log('\n');
  }
  const errorSummary = {};
  const checkEntries = Object.entries(checks).filter(([type]) => !options.skipChecks.includes(type));
  const formattedWarnings = [];
  let formattedErrors = [];
  let formattedInfos = [];
  for (const [type, check] of checkEntries) {
    const formattedOutput = check.outputFormatter(check, type, options.isImport);
    for (const error of formattedOutput.errors) {
      if ('warning' in error) {
        formattedWarnings.push(error);
      } else {
        formattedErrors.push(error);
      }
    }
    formattedInfos = formattedInfos.concat(formattedOutput.infos);
    errorSummary[type] = check.results.length;
  }
  // eslint-disable-next-line camelcase
  errorSummary.problems_found = problemsFound;
  const tableNamesSet = new Set(tableNames);
  if (tableNames.length > tableNamesSet.size) {
    // there was a duplciate table
    problemsFound++;
    const duplicates = findDuplicates(tableNames, tableNamesSet);
    const errorObject = {
      error: formatError('Duplicate table names were found: ' + duplicates.join(',')),
      recommendation: formatRecommendation('Ensure that there are no duplicate tables in your SQL dump')
    };
    formattedErrors = formattedErrors.concat(errorObject);
  }
  if (formattedWarnings.length) {
    const warningOutput = [];
    formattedWarnings.forEach(warning => {
      warningOutput.push(warning.warning);
      if (warning.recommendation) {
        warningOutput.push(warning.recommendation);
      }
      warningOutput.push('');
    });
    console.log(warningOutput.join('\n'));
    console.log('');
  }
  if (problemsFound > 0) {
    await (0, _tracker.trackEvent)('import_validate_sql_command_failure', {
      is_import: options.isImport,
      error: errorSummary
    });
    const errorOutput = [];
    formattedErrors.forEach(error => {
      errorOutput.push(error.error);
      if (error.recommendation) {
        errorOutput.push(error.recommendation);
      }
      errorOutput.push('');
    });
    errorOutput.push(_chalk.default.bold.red(`SQL validation failed due to ${problemsFound} error(s)`));
    if (options.isImport) {
      throw new Error(errorOutput.join('\n'));
    }
    exit.withError(errorOutput.join('\n'));
  }
  if (!options.isImport) {
    console.log(formattedInfos.join('\n'));
    console.log('');
  }
  await (0, _tracker.trackEvent)('import_validate_sql_command_success', {
    is_import: options.isImport
  });
};
const getTableNames = () => {
  return tableNames;
};
exports.getTableNames = getTableNames;
const checkForTableName = line => {
  const matches = /(?<=^CREATE\sTABLE\s)`?(?:(wp_[\d+_]?\w+))`?/.exec(line);
  if (matches) {
    const tableName = matches[1];
    // we should only have one match if we have any since we're looking at the start of the string
    tableNames.push(tableName);
  }
};
const DEFAULT_VALIDATION_OPTIONS = {
  isImport: true,
  skipChecks: DEV_ENV_SPECIFIC_CHECKS,
  extraCheckParams: {}
};
const perLineValidations = (line, options = DEFAULT_VALIDATION_OPTIONS) => {
  if (options.isImport && lineNum % 500 === 0) {
    (0, _singleLineLog.stdout)(`Reading line ${lineNum} `);
  }
  checkForTableName(line);
  const checkKeys = Object.keys(checks).filter(checkItem => !options.skipChecks.includes(checkItem));
  for (const checkKey of checkKeys) {
    const check = checks[checkKey];
    const results = line.match(check.matcher); // NOSONAR
    const extraCheckParams = options.extraCheckParams[checkKey];
    if (results) {
      check.results.push(check.matchHandler(lineNum, results, extraCheckParams));
    }
  }
  lineNum += 1;
};
const postLineExecutionProcessing = async ({
  isImport,
  skipChecks
}) => {
  await postValidation({
    isImport: isImport ?? false,
    skipChecks: skipChecks ?? DEV_ENV_SPECIFIC_CHECKS,
    extraCheckParams: {}
  });
};
const staticSqlValidations = exports.staticSqlValidations = {
  execute: perLineValidations,
  postLineExecutionProcessing
};

// For standalone SQL validations
const validate = async (filename, options = DEFAULT_VALIDATION_OPTIONS) => {
  const fileMeta = await (0, _clientFileUploader.getFileMeta)(filename);
  if (fileMeta.isCompressed) {
    exit.withError('Compressed files cannot be validated. Please extract the archive and re-run the command, providing the path to the extracted SQL file.');
  }
  const readInterface = await (0, _lineByLine.getReadInterface)(filename);
  options.isImport = false;
  readInterface.on('line', line => {
    perLineValidations(line, options);
  });

  // Block until the processing completes
  await new Promise(resolve => readInterface.on('close', resolve));
  readInterface.close();
  await postLineExecutionProcessing({
    isImport: options.isImport,
    skipChecks: options.skipChecks
  });
};
exports.validate = validate;