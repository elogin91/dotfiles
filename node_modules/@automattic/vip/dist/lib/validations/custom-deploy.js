"use strict";

exports.__esModule = true;
exports.validateDeployFileExt = validateDeployFileExt;
exports.validateFilename = validateFilename;
exports.validateName = validateName;
exports.validateTarFile = validateTarFile;
exports.validateZipFile = validateZipFile;
var _admZip = _interopRequireDefault(require("adm-zip"));
var _nodeFs = require("node:fs");
var _path = _interopRequireDefault(require("path"));
var tar = _interopRequireWildcard(require("tar"));
var exit = _interopRequireWildcard(require("../../lib/cli/exit"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const errorMessages = {
  missingThemes: 'Missing `themes` directory from root folder.',
  symlink: 'Symlink detected: ',
  singleRootDir: 'The compressed file must contain a single root directory.',
  invalidExt: 'Invalid file extension. Please provide a .zip, .tar.gz, or a .tgz file.',
  invalidChars: (filename, invalidChars) => `Filename ${filename} contains disallowed characters: ${invalidChars}`
};
const symlinkIgnorePattern = /\/node_modules\/[^/]+\/\.bin\//;
const macosxDir = '__MACOSX';

/**
 * Check if a file has a valid extension
 *
 * @param {string} filename The file extension
 * @returns {boolean} True if the extension is valid
 */
function validateDeployFileExt(filename) {
  let ext = _path.default.extname(filename).toLowerCase();
  if (ext === '.gz' && _path.default.extname(_path.default.basename(filename, ext)) === '.tar') {
    ext = '.tar.gz';
  }
  if (!['.zip', '.tar.gz', '.tgz'].includes(ext)) {
    exit.withError(errorMessages.invalidExt);
  }
}

/**
 * Check if a file has a valid name
 * @param {string} filename The file name
 * @returns {boolean} True if the filename is valid
 */
function validateFilename(filename) {
  const re = /^[a-z0-9\-_.]+$/i;
  if (!re.test(filename)) {
    exit.withError(errorMessages.invalidChars(filename, '[0-9,a-z,A-Z,-,_,.]'));
  }
}

/**
 * Validate the name of a file for disallowed characters
 *
 * @param {string} name The name of the file
 * @param {bool} isDirectory Whether the file is a directory
 */
function validateName(name, isDirectory) {
  if (name.startsWith('._')) {
    return;
  }
  const invalidCharsPattern = isDirectory ? /[!:*?"<>|']|^\.\..*$/ : /[!/:*?"<>|']|^\.\..*$/;
  const errorMessage = errorMessages.invalidChars(name, isDirectory ? '[!:*?"<>|\'/^..]+' : '[!/:*?"<>|\'/^..]+');
  if (invalidCharsPattern.test(name)) {
    exit.withError(errorMessage);
  }
}

/**
 * Validate the existence of a symlink in a zip file. Ignores symlinks in node_modules/.bin/
 *
 * @param {IZipEntry} entry The zip entry to validate
 */
function validateZipSymlink(entry) {
  if (symlinkIgnorePattern.test(entry.entryName)) {
    return;
  }
  const madeBy = entry.header.made >> 8; // eslint-disable-line no-bitwise
  const errorMsg = errorMessages.symlink + entry.name;

  // DOS
  /* eslint-disable no-bitwise */
  if (madeBy === 0 && (entry.attr & 0x0400) === 0x0400) {
    exit.withError(errorMsg);
  }

  // Unix
  if (madeBy === 3 && (entry.attr >>> 16 & _nodeFs.constants.S_IFLNK) === _nodeFs.constants.S_IFLNK) {
    /* eslint-enable no-bitwise */
    exit.withError(errorMsg);
  }
}

/**
 * Validate a zip entry for disallowed characters and symlinks.
 * Ignores __MACOSX directories.
 *
 * @param {IZipEntry} entry The zip entry to validate
 */
function validateZipEntry(entry) {
  if (entry.entryName.startsWith(macosxDir)) {
    return;
  }
  validateName(entry.isDirectory ? entry.entryName : entry.name, entry.isDirectory);
  validateZipSymlink(entry);
}

/**
 * Validate the existence of a themes directory in the root folder.
 *
 * @param {IZipEntry[]} zipEntries The zip entries to validate
 */
function validateZipThemes(rootFolder, zipEntries) {
  const hasThemesDir = zipEntries.some(entry => entry.isDirectory && entry.entryName.startsWith(_path.default.join(rootFolder, 'themes/')));
  if (!hasThemesDir) {
    exit.withError(errorMessages.missingThemes);
  }
}

/**
 * Validate a zip file for Custom Deployments.
 *
 * @param {string} filePath The path to the zip file
 */
function validateZipFile(filePath) {
  try {
    const zipFile = new _admZip.default(filePath);
    const zipEntries = zipFile.getEntries();
    const rootDirs = zipEntries.filter(entry => entry.isDirectory && !entry.entryName.startsWith(macosxDir) && (entry.entryName.match(/\//g) || []).length === 1);
    if (rootDirs.length !== 1) {
      exit.withError(errorMessages.singleRootDir);
    }
    const rootFolder = rootDirs[0].entryName;
    validateZipThemes(rootFolder, zipEntries);
    zipEntries.forEach(entry => validateZipEntry(entry));
  } catch (error) {
    const err = error;
    exit.withError(`Error reading file: ${err.message}`);
  }
}

/**
 * Validate the existence of a themes directory in the root folder in a tar file.
 *
 * @param {string} rootFolder The root folder of the tar file
 * @param {TarEntry[]} tarEntries The list of tar entries
 */
function validateTarThemes(rootFolder, tarEntries) {
  const themesFolderPath = _path.default.join(rootFolder, 'themes/');
  const themesFolderExists = tarEntries.some(entry => entry.path === themesFolderPath && entry.type === 'Directory');
  if (!themesFolderExists) {
    exit.withError(errorMessages.missingThemes);
  }
}

/**
 * Validate a tar entry for disallowed characters and symlinks.
 *
 * @param {TarEntry} entry The tar entry to validate
 */
function validateTarEntry(entry) {
  if (entry.path.startsWith(macosxDir)) {
    return;
  }
  validateTarSymlink(entry);
  validateName(_path.default.basename(entry.path), entry.type === 'Directory');
}

/**
 * Validate the existence of a symlink in a tar file. Ignores symlinks in node_modules/.bin/
 *
 * @param {TarEntry} entry The tar entry to validate for symlinks
 */
function validateTarSymlink(entry) {
  if (symlinkIgnorePattern.test(entry.path)) {
    return;
  }
  if (entry.type === 'SymbolicLink') {
    exit.withError(errorMessages.symlink + entry.path);
  }
}

/**
 * Validate a tar file for Custom Deployments.
 *
 * @param {string} filePath The path to the tar file
 */
async function validateTarFile(filePath) {
  const tarEntries = [];
  let rootFolder = null;
  try {
    await tar.list({
      file: filePath,
      onReadEntry: entry => {
        if (entry.path.startsWith(macosxDir)) {
          return;
        }
        if (entry.type !== 'File' && entry.type !== 'Directory' && entry.type !== 'SymbolicLink') {
          return;
        }
        const isRootFolder = entry.type === 'Directory' && entry.path.endsWith('/') && (entry.path.match(/\//g) || []).length === 1;
        if (isRootFolder) {
          if (rootFolder === null) {
            rootFolder = entry.path;
          } else if (rootFolder !== entry.path) {
            exit.withError(errorMessages.singleRootDir);
          }
        }
        const entryInfo = {
          path: entry.path,
          type: entry.type,
          mode: entry.mode
        };
        validateTarEntry(entryInfo);
        tarEntries.push(entryInfo);
      }
    });
    if (!rootFolder) {
      exit.withError(errorMessages.singleRootDir);
    }
    validateTarThemes(rootFolder, tarEntries);
  } catch (error) {
    const err = error;
    exit.withError(err.message);
  }
}