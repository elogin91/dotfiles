"use strict";

exports.__esModule = true;
exports.validateCustomDeployKey = validateCustomDeployKey;
exports.validateFile = validateFile;
var _fs = _interopRequireDefault(require("fs"));
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _api = _interopRequireDefault(require("../../lib/api"));
var exit = _interopRequireWildcard(require("../../lib/cli/exit"));
var _clientFileUploader = require("../../lib/client-file-uploader");
var _fileSize = require("../../lib/constants/file-size");
var _tracker = require("../../lib/tracker");
var _customDeploy = require("../../lib/validations/custom-deploy");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const DEPLOY_MAX_FILE_SIZE = 4 * _fileSize.GB_IN_BYTES;
const WPVIP_DEPLOY_TOKEN = process.env.WPVIP_DEPLOY_TOKEN;
async function validateCustomDeployKey(app, env) {
  if (!WPVIP_DEPLOY_TOKEN) {
    exit.withError('Valid custom deploy key is required.');
  }
  const VALIDATE_CUSTOM_DEPLOY_ACCESS_MUTATION = (0, _graphqlTag.default)`
	mutation ValidateCustomDeployAccess {
		validateCustomDeployAccess( input: { app: "${String(app)}", env: "${String(env)}" } ) {
			success,
			appId,
			envId,
			envType,
			envUniqueLabel,
			primaryDomainName,
			launched
		}
	}
`;
  const api = (0, _api.default)({
    exitOnError: true
  });
  try {
    const result = await api.mutate({
      mutation: VALIDATE_CUSTOM_DEPLOY_ACCESS_MUTATION,
      context: {
        headers: {
          Authorization: `Bearer ${WPVIP_DEPLOY_TOKEN}`
        }
      }
    });
    if (!result.data?.validateCustomDeployAccess) {
      throw new Error('Not found');
    }
    return result.data?.validateCustomDeployAccess;
  } catch (error) {
    exit.withError(`Unauthorized: Invalid or non-existent custom deploy key for environment.`);
  }
}

/**
 * @param {FileMeta} fileMeta
 */
async function validateFile(appId, envId, fileMeta) {
  const {
    fileName,
    basename,
    isCompressed
  } = fileMeta;
  const track = _tracker.trackEventWithEnv.bind(null, appId, envId);
  if (!_fs.default.existsSync(fileName)) {
    await track('deploy_app_command_error', {
      error_type: 'invalid-file'
    });
    exit.withError(`Unable to access file ${fileMeta.fileName}`);
  }
  if (!isCompressed) {
    await track('deploy_app_command_error', {
      error_type: 'uncompressed-file'
    });
    exit.withError(`Please compress file ${fileMeta.fileName} before uploading.`);
  }
  try {
    (0, _customDeploy.validateFilename)(basename);
  } catch (error) {
    await track('deploy_app_command_error', {
      error_type: 'invalid-filename'
    });
    exit.withError(error);
  }
  try {
    (0, _customDeploy.validateDeployFileExt)(fileName);
  } catch (error) {
    await track('deploy_app_command_error', {
      error_type: 'invalid-extension'
    });
    exit.withError(error);
  }
  try {
    await (0, _clientFileUploader.checkFileAccess)(fileName);
  } catch (err) {
    await track('deploy_app_command_error', {
      error_type: 'appfile-unreadable'
    });
    exit.withError(`File '${fileName}' does not exist or is not readable.`);
  }
  if (!(await (0, _clientFileUploader.isFile)(fileName))) {
    await track('deploy_app_command_error', {
      error_type: 'appfile-notfile'
    });
    exit.withError(`Path '${fileName}' is not a file.`);
  }
  const fileSize = await (0, _clientFileUploader.getFileSize)(fileName);
  if (!fileSize) {
    await track('deploy_app_command_error', {
      error_type: 'appfile-empty'
    });
    exit.withError(`File '${fileName}' is empty.`);
  }
  if (fileSize > DEPLOY_MAX_FILE_SIZE) {
    await track('deploy_app_command_error', {
      error_type: 'appfile-toobig',
      file_size: fileSize
    });
    exit.withError(`The deploy file size (${fileSize} bytes) exceeds the limit (${DEPLOY_MAX_FILE_SIZE} bytes).`);
  }
}