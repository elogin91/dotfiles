"use strict";

exports.__esModule = true;
exports.getReadAndWriteStreams = getReadAndWriteStreams;
exports.searchAndReplace = void 0;
var _vipSearchReplace = require("@automattic/vip-search-replace");
var _chalk = require("chalk");
var _debug = _interopRequireDefault(require("debug"));
var _fs = _interopRequireDefault(require("fs"));
var _promises = require("node:stream/promises");
var _path = _interopRequireDefault(require("path"));
var _database = require("./database");
var _utils = require("./utils");
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _prompt = require("../lib/cli/prompt");
var _clientFileUploader = require("../lib/client-file-uploader");
var _tracker = require("../lib/tracker");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('@automattic/vip:lib:search-and-replace');
function getReadAndWriteStreams({
  fileName,
  inPlace,
  output
}) {
  let writeStream;
  let usingStdOut = false;
  let outputFileName;
  if (inPlace) {
    const midputFileName = _path.default.join((0, _utils.makeTempDir)('vip-search-replace'), _path.default.basename(fileName));
    _fs.default.copyFileSync(fileName, midputFileName);
    debug(`Copied input file to ${midputFileName}`);
    debug(`Set output to the original file path ${fileName}`);
    outputFileName = fileName;
    return {
      outputFileName,
      readStream: _fs.default.createReadStream(midputFileName),
      usingStdOut,
      writeStream: _fs.default.createWriteStream(fileName)
    };
  }
  debug(`Reading input from file: ${fileName}`);
  switch (typeof output) {
    case 'string':
      writeStream = _fs.default.createWriteStream(output);
      outputFileName = output;
      debug(`Outputting to file: ${outputFileName}`);
      break;
    case 'object':
      writeStream = output;
      if (writeStream === process.stdout) {
        usingStdOut = true;
        debug('Outputting to the standard output stream');
      } else {
        debug('Outputting to the provided output stream');
      }
      break;
    default:
      {
        const tmpOutFile = _path.default.join((0, _utils.makeTempDir)('vip-search-replace'), _path.default.basename(fileName));
        writeStream = _fs.default.createWriteStream(tmpOutFile);
        outputFileName = tmpOutFile;
        debug(`Outputting to file: ${outputFileName}`);
        break;
      }
  }
  return {
    outputFileName,
    readStream: _fs.default.createReadStream(fileName),
    usingStdOut,
    writeStream
  };
}
const searchAndReplace = async (fileName, pairs, {
  isImport = true,
  inPlace = false,
  output = process.stdout
}, binary = null) => {
  const dumpDetails = await (0, _database.getSqlDumpDetails)(fileName);
  const isMyDumper = dumpDetails.type === _database.SqlDumpType.MYDUMPER;
  await (0, _tracker.trackEvent)('searchreplace_started', {
    is_import: isImport,
    in_place: inPlace,
    sqldump_type: dumpDetails.type
  });
  const startTime = process.hrtime();
  const fileSize = (0, _clientFileUploader.getFileSize)(fileName);

  // if we don't have any pairs to replace with, return the input file
  if (!pairs.length) {
    throw new Error('No search and replace parameters provided.');
  }

  // If only one pair is provided, ensure we have an array
  if (!Array.isArray(pairs)) {
    pairs = [pairs];
  }

  // determine all the replacements required
  const replacements = pairs.flatMap(pair => pair.split(',').map(str => str.trim()));
  debug('Pairs: ', pairs, 'Replacements: ', replacements);
  if (inPlace) {
    const approved = await (0, _prompt.confirm)([], 'Are you sure you want to run search and replace on your input file? This operation is not reversible.');

    // Bail if user does not wish to proceed
    if (!approved) {
      await (0, _tracker.trackEvent)('search_replace_in_place_cancelled', {
        is_import: isImport,
        in_place: inPlace,
        sqldump_type: dumpDetails.type
      });
      process.exit();
    }
  }
  const {
    usingStdOut,
    outputFileName,
    readStream,
    writeStream
  } = getReadAndWriteStreams({
    fileName,
    inPlace,
    output
  });
  let replacedStream;
  try {
    replacedStream = await (0, _vipSearchReplace.replace)(readStream, replacements, binary);
  } catch (replaceError) {
    // replace() throws strings... OMG
    exit.withError(replaceError);
  }
  const streams = [replacedStream];
  if (isMyDumper) {
    streams.push((0, _database.fixMyDumperTransform)());
  }
  streams.push(writeStream);
  try {
    await (0, _promises.pipeline)(streams);
  } catch (error) {
    console.log((0, _chalk.red)("Oh no! We couldn't write to the output file.  Please check your available disk space and file/folder permissions."));
    throw error;
  }
  const endTime = process.hrtime(startTime);
  const end = endTime[1] / 1000000; // time in ms

  await (0, _tracker.trackEvent)('searchreplace_completed', {
    time_to_run: end,
    file_size: fileSize,
    sqldump_type: dumpDetails.type
  });
  return {
    inputFileName: fileName,
    outputFileName,
    usingStdOut
  };
};
exports.searchAndReplace = searchAndReplace;