"use strict";

exports.__esModule = true;
exports.default = void 0;
exports.getGlyphForStatus = getGlyphForStatus;
exports.mediaImportCheckStatus = mediaImportCheckStatus;
var _chalk = _interopRequireDefault(require("chalk"));
var _enquirer = require("enquirer");
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _promises = require("node:fs/promises");
var _nodePath = require("node:path");
var _api = _interopRequireDefault(require("../../lib/api"));
var _format = require("../../lib/cli/format");
var _mediaFileImport = require("../../lib/media-import/media-file-import");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const IMPORT_MEDIA_PROGRESS_POLL_INTERVAL = 1000;
const ONE_MINUTE_IN_MILLISECONDS = 1000 * 60;
const TWO_MINUTES_IN_MILLISECONDS = 2 * ONE_MINUTE_IN_MILLISECONDS;
const IMPORT_MEDIA_PROGRESS_QUERY = (0, _graphqlTag.default)`
	query App($appId: Int, $envId: Int) {
		app(id: $appId) {
			environments(id: $envId) {
				id
				name
				type
				repo
				mediaImportStatus {
					importId
					siteId
					status
					filesTotal
					filesProcessed
					failureDetails {
						previousStatus
						globalErrors
						fileErrorsUrl
					}
				}
			}
		}
	}
`;
async function getStatus(api, appId, envId) {
  const response = await api.query({
    query: IMPORT_MEDIA_PROGRESS_QUERY,
    variables: {
      appId,
      envId
    },
    fetchPolicy: 'network-only'
  });
  const environments = response.data.app?.environments;
  if (!environments?.length) {
    throw new Error('Unable to determine import status from environment');
  }
  const [environment] = environments;
  const {
    mediaImportStatus
  } = environment ?? {};
  return mediaImportStatus ?? null;
}
function getGlyphForStatus(status, runningSprite) {
  switch (status) {
    case 'INITIALIZING':
      return '○';
    case 'INITIALIZED':
    case 'RUNNING':
    case 'COMPLETING':
    case 'RAN':
    case 'VALIDATING':
    case 'VALIDATED':
      return _chalk.default.blueBright(runningSprite);
    case 'COMPLETED':
      return _chalk.default.green('✓');
    case 'FAILED':
      return _chalk.default.red('✕');
    case 'ABORTED':
    case 'ABORTING':
      return _chalk.default.yellow('⚠️');
    default:
      return '';
  }
}
function buildErrorMessage(importFailed) {
  let message = '';
  if ('FAILED' === importFailed.status) {
    const globalFailureDetails = importFailed.failureDetails;
    if (globalFailureDetails) {
      message += `${_chalk.default.red('Import failed at status: ')}`;
      message += `${_chalk.default.redBright.bold(globalFailureDetails.previousStatus)}\n`;
      message += _chalk.default.red('Errors:');
      globalFailureDetails.globalErrors?.forEach(value => {
        message += `\n\t- ${_chalk.default.redBright.bold(value)}`;
      });
      return message;
    }
  }
  message += _chalk.default.red(importFailed.error ? importFailed.error : importFailed);
  message += '\n\nPlease check the status of your Import using `vip import media status @mysite.production`';
  message += '\n\nIf this error persists and you are not sure on how to fix, please contact support\n';
  return message;
}
function buildFileErrors(fileErrors, exportFileErrorsToJson) {
  if (exportFileErrorsToJson) {
    const fileErrorsToExport = fileErrors.map(fileError => {
      return {
        fileName: fileError?.fileName,
        errors: fileError?.errors
      };
    });
    return (0, _format.formatData)(fileErrorsToExport, 'json');
  }
  let errorString = '';
  for (const fileError of fileErrors) {
    errorString += `File Name: ${fileError?.fileName ?? 'N/A'}`;
    errorString += `\n\nErrors:\n\t- ${fileError?.errors?.join(', ') ?? 'unknown error'}\n\n\n\n`;
  }
  return errorString;
}
async function mediaImportCheckStatus({
  app,
  env,
  progressTracker,
  exportFileErrorsToJson
}) {
  // Stop printing so we can pass our callback
  progressTracker.stopPrinting();

  // NO `console.log` in this function (until results are final)! It will break the progress printing.
  const api = (0, _api.default)();
  if (!(0, _mediaFileImport.currentUserCanImportForApp)(app)) {
    throw new Error('The currently authenticated account does not have permission to view Media Import status.');
  }
  let overallStatus = 'Checking...';
  const setProgressTrackerSuffix = () => {
    const sprite = getGlyphForStatus(overallStatus, progressTracker.runningSprite);
    const exitPrompt = '(Press ^C to hide progress. The import will continue in the background.)';
    let statusMessage;
    switch (overallStatus) {
      case 'INITIALIZING':
        statusMessage = `INITIALIZING ${sprite} : We're downloading the files to be imported...`;
        break;
      case 'COMPLETED':
        statusMessage = `COMPLETED ${sprite} : The imported files should be visible on your App`;
        break;
      default:
        statusMessage = `${(0, _format.capitalize)(overallStatus)} ${sprite}`;
    }
    const maybeExitPrompt = ['COMPLETED', 'ABORTED', 'FAILED'].includes(overallStatus) ? '' : exitPrompt;
    const suffix = `
=============================================================
Status: ${statusMessage}
App: ${app.name ?? 'N/A'} (${(0, _format.formatEnvironment)(env.type ?? 'N/A')})
=============================================================
${maybeExitPrompt}
`;
    progressTracker.suffix = suffix;
  };
  const setSuffixAndPrint = () => {
    setProgressTrackerSuffix();
    progressTracker.print();
  };
  progressTracker.startPrinting(setSuffixAndPrint);
  const getResults = () =>
  // eslint-disable-next-line @typescript-eslint/no-shadow
  new Promise((resolve, reject) => {
    let startDate = Date.now();
    let pollIntervalDecreasing = false;
    const checkStatus = async pollInterval => {
      let mediaImportStatus = null;
      try {
        mediaImportStatus = await getStatus(api, app.id ?? -1, env.id ?? -1);
        if (!mediaImportStatus) {
          return reject({
            error: 'Requested app/environment is not available for this operation. If you think this is not correct, please contact Support.'
          });
        }
      } catch (error) {
        return reject({
          error: error.message
        });
      }
      const status = mediaImportStatus.status ?? 'unknown';
      const failedMediaImport = 'FAILED' === status;
      if (failedMediaImport) {
        progressTracker.setStatus(mediaImportStatus);
        overallStatus = 'FAILED';
        setSuffixAndPrint();
        return reject({
          ...mediaImportStatus,
          error: 'Import FAILED'
        });
      }
      progressTracker.setStatus(mediaImportStatus);
      setSuffixAndPrint();
      if (['COMPLETED', 'ABORTED'].includes(status)) {
        return resolve(mediaImportStatus);
      }
      overallStatus = status;

      // after two minutes, we'll start decreasing the pollInterval
      pollIntervalDecreasing = pollIntervalDecreasing || startDate < Date.now() - TWO_MINUTES_IN_MILLISECONDS;

      // decrease poll interval by a second, every minute
      if (pollIntervalDecreasing && startDate < Date.now() - ONE_MINUTE_IN_MILLISECONDS) {
        pollInterval = pollInterval + IMPORT_MEDIA_PROGRESS_POLL_INTERVAL;
        startDate = Date.now();
      }
      setTimeout(() => {
        void checkStatus(pollInterval);
      }, pollInterval);
    };

    // Kick off the check
    void checkStatus(IMPORT_MEDIA_PROGRESS_POLL_INTERVAL);
  });
  async function exportFailureDetails(fileErrors) {
    const formattedData = buildFileErrors(fileErrors, exportFileErrorsToJson);
    const errorsFile = `media-import-${app.name ?? ''}-${Date.now()}${exportFileErrorsToJson ? '.json' : '.txt'}`;
    try {
      await (0, _promises.writeFile)(errorsFile, formattedData);
      progressTracker.suffix += `${_chalk.default.yellow(`⚠️  All errors have been exported to ${_chalk.default.bold((0, _nodePath.resolve)(errorsFile))}\n`)}`;
    } catch (writeFileErr) {
      progressTracker.suffix += `${_chalk.default.red(`Could not export errors to file\n${writeFileErr.message}`)}`;
    }
  }
  async function fetchFailureDetails(fileErrorsUrl) {
    progressTracker.suffix += `
=============================================================
Downloading errors details from ${fileErrorsUrl}
\n`;
    progressTracker.print({
      clearAfter: true
    });
    try {
      const response = await fetch(fileErrorsUrl);
      return await response.json();
    } catch (err) {
      progressTracker.suffix += `${_chalk.default.red(`Could not download import errors report\n${err.message}`)}`;
      throw err;
    }
  }
  async function promptFailureDetailsDownload(fileErrorsUrl) {
    const failureDetails = await (0, _enquirer.prompt)({
      type: 'confirm',
      name: 'download',
      message: 'Download import errors report now? (Report will be downloadable for up to 7 days from the completion of the import)'
    });
    if (!failureDetails.download) {
      progressTracker.suffix += `${_chalk.default.yellow(`⚠️  An error report file has been generated for this media import. Access it within the next 15 minutes by clicking on the URL below.`)}`;
      progressTracker.suffix += `\n${_chalk.default.yellow(`Or, generate a new URL by running the ${_chalk.default.bgYellow('vip import media status')} command.`)} `;
      progressTracker.suffix += `\n${_chalk.default.yellow('The report will be downloadable for up to 7 days after the completion of the import or until a new media import is performed.')}`;
      progressTracker.suffix += `\n\n${_chalk.default.underline(fileErrorsUrl)}\n`;
      progressTracker.print({
        clearAfter: true
      });
      return;
    }
    const failureDetailsErrors = await fetchFailureDetails(fileErrorsUrl);
    await exportFailureDetails(failureDetailsErrors);
  }
  function printFileErrorsReportLinkExpiredError(results) {
    if (results.filesTotal && results.filesProcessed && results.filesTotal !== results.filesProcessed) {
      const errorsFound = results.filesTotal - results.filesProcessed;
      progressTracker.suffix += `${_chalk.default.yellow(`⚠️  ${errorsFound} error(s) were found. File import errors report link expired.`)}`;
    }
  }
  try {
    const results = await getResults();
    overallStatus = results.status ?? 'unknown';
    progressTracker.stopPrinting();
    setProgressTrackerSuffix();
    progressTracker.print();
    if (results.failureDetails?.fileErrorsUrl) {
      await promptFailureDetailsDownload(results.failureDetails.fileErrorsUrl);
    } else if ('ABORTED' !== overallStatus) {
      // print report link expired if required
      // do not print this message if the import was aborted
      printFileErrorsReportLinkExpiredError(results);
    }

    // Print one final time
    progressTracker.print({
      clearAfter: true
    });
    process.exit(0);
  } catch (importFailed) {
    progressTracker.stopPrinting();
    progressTracker.print();
    progressTracker.suffix += `\n${buildErrorMessage(importFailed)}`;
    progressTracker.print({
      clearAfter: true
    });
    process.exit(1);
  }
}
var _default = exports.default = {
  mediaImportCheckStatus
};