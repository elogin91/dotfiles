"use strict";

exports.__esModule = true;
exports.default = void 0;
var _debug = _interopRequireDefault(require("debug"));
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _api = require("../../lib/api");
var _env = _interopRequireDefault(require("../../lib/env"));
var _proxyAgent = require("../../lib/http/proxy-agent");
var _token = _interopRequireDefault(require("../../lib/token"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('@automattic/vip:http');
/**
 * Call the Public API with an arbitrary path (e.g. to connect to REST endpoints).
 * This will include the token in an Authorization header so requests are "logged-in."
 *
 * This is simply a wrapper around node-fetch
 *
 * @param {string} path    API path to pass to `fetch` -- will be prefixed by the API_HOST
 * @param {Object} options options to pass to `fetch`
 * @return {Promise} Return value of the `fetch` call
 */
var _default = async (path, options = {}) => {
  let url = path;

  // For convenience, we support just passing in the path to this function...
  // but some things (Apollo) always pass the full url
  if (!path.startsWith(_api.API_HOST)) {
    url = `${_api.API_HOST}${path}`;
  }
  const authToken = await _token.default.get();
  const proxyAgent = (0, _proxyAgent.createProxyAgent)(url);
  debug('running fetch', url);
  return (0, _nodeFetch.default)(url, {
    ...options,
    agent: proxyAgent ?? undefined,
    headers: {
      Authorization: `Bearer ${authToken.raw}`,
      'User-Agent': _env.default.userAgent,
      'Content-Type': 'application/json',
      ...(options.headers ?? {})
    },
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    body: typeof options.body === 'object' ? JSON.stringify(options.body) : options.body
  });
};
exports.default = _default;