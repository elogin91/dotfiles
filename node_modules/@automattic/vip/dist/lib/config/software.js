"use strict";

exports.__esModule = true;
exports.triggerUpdate = exports.promptForUpdate = exports.getUpdateResult = exports.formatSoftwareSettings = exports.appQueryFragments = exports.appQuery = void 0;
var _debug = _interopRequireDefault(require("debug"));
var _enquirer = require("enquirer");
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _promises = require("node:timers/promises");
var _api = _interopRequireDefault(require("../api"));
var _app = require("../app");
var _userError = _interopRequireDefault(require("../user-error"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const UPDATE_PROGRESS_POLL_INTERVAL = 5;
const debug = (0, _debug.default)('@automattic/vip:bin:config-software');
const appQuery = exports.appQuery = `
	id,
	name,
	type,
	typeId,
	organization { id, name },
	environments{
		appId
		id
		name
		type
		uniqueLabel
		softwareSettings {
			php {
			  ...Software
			}
			wordpress {
			  ...Software
			}
			muplugins {
			  ...Software
			}
			nodejs {
			  ...Software
			}
		}
	}`;
const appQueryFragments = exports.appQueryFragments = `fragment Software on AppEnvironmentSoftwareSettingsSoftware {
		name
		slug
		pinned
		current {
		  version
		  default
		  deprecated
		  unstable
		  compatible
		  latestRelease
		  private
		}
		options {
		  version
		  default
		  deprecated
		  unstable
		  compatible
		  latestRelease
		  private
		}
	}
`;
const updateSoftwareMutation = (0, _graphqlTag.default)`
	mutation UpdateSoftwareSettings(
		$appId: Int!
		$envId: Int!
		$component: String!
		$version: String!
	) {
		updateSoftwareSettings(
			input: {
				appId: $appId
				environmentId: $envId
				softwareName: $component
				softwareVersion: $version
			}
		) {
			php {
				...Software
			}
			wordpress {
				...Software
			}
			muplugins {
				...Software
			}
			nodejs {
				...Software
			}
		}
	}
	${appQueryFragments}
`;
const updateJobQuery = (0, _graphqlTag.default)`
	query UpdateJob($appId: Int!, $envId: Int!) {
		app(id: $appId) {
			environments(id: $envId) {
				jobs(types: ["upgrade_php", "upgrade_wordpress", "upgrade_muplugins", "upgrade_nodejs"]) {
					type
					completedAt
					createdAt
					inProgressLock
					progress {
						status
						steps {
							step
							name
							status
						}
					}
				}
			}
		}
	}
`;
const COMPONENT_NAMES = {
  wordpress: 'WordPress',
  php: 'PHP',
  muplugins: 'MU Plugins',
  nodejs: 'Node.js'
};
const MANAGED_OPTION_KEY = 'managed_latest';
const _optionsForVersion = softwareSettings => {
  const {
    options,
    current,
    pinned,
    slug
  } = softwareSettings;
  const versionChoices = {
    managed: [],
    supported: [],
    test: [],
    deprecated: []
  };
  for (const option of options) {
    if (option.deprecated) {
      versionChoices.deprecated.push({
        message: `${option.version} (deprecated)`,
        value: option.version
      });
    } else if (option.unstable) {
      versionChoices.test.push({
        message: `${option.version} (test)`,
        value: option.version
      });
    } else {
      versionChoices.supported.push({
        message: option.version,
        value: option.version
      });
    }
  }
  if (slug === 'wordpress') {
    versionChoices.managed.push({
      message: 'Managed updates',
      value: MANAGED_OPTION_KEY
    });
  }
  const allOptions = [...versionChoices.managed, ...versionChoices.supported, ...versionChoices.test, ...versionChoices.deprecated];
  return allOptions.map(option => {
    const isActivePinned = option.value === MANAGED_OPTION_KEY && !pinned;
    const isActiveVersion = option.value === current.version && pinned;
    if (isActivePinned || isActiveVersion) {
      return {
        message: `Active: ${option.message}`,
        value: option.value,
        disabled: true
      };
    }
    return option;
  });
};
const _processComponent = (appTypeId, userProvidedComponent) => {
  const validComponents = [];
  if ((0, _app.isAppWordPress)(appTypeId)) {
    validComponents.push('wordpress', 'php', 'muplugins');
  } else if ((0, _app.isAppNodejs)(appTypeId)) {
    validComponents.push('nodejs');
  }
  if (userProvidedComponent) {
    if (!validComponents.includes(userProvidedComponent)) {
      throw new _userError.default(`Component ${userProvidedComponent} is not supported. Use one of: ${validComponents.join(',')}`);
    }
    return Promise.resolve(userProvidedComponent);
  }
  if (validComponents.length === 0) {
    throw new _userError.default('No components are supported for this application');
  }
  if (validComponents.length === 1) {
    return Promise.resolve(validComponents[0]);
  }
  const choices = validComponents.map(item => ({
    message: COMPONENT_NAMES[item],
    value: item
  }));
  const select = new _enquirer.Select({
    message: 'Component to update',
    choices
  });
  return select.run().catch(() => {
    throw new _userError.default('Command cancelled by user.');
  });
};
const _processComponentVersion = (softwareSettings, component, userProvidedVersion) => {
  const versionChoices = _optionsForVersion(softwareSettings[component]);
  if (userProvidedVersion) {
    const validValues = versionChoices.map(item => item.value);
    if (!validValues.includes(userProvidedVersion)) {
      throw new _userError.default(`Version ${userProvidedVersion} is not supported for ${COMPONENT_NAMES[component]}. Use one of: ${validValues.join(',')}`);
    }
    return Promise.resolve(userProvidedVersion);
  }
  const versionSelect = new _enquirer.Select({
    message: `Version for ${COMPONENT_NAMES[component]} to upgrade to`,
    choices: versionChoices
  });
  return versionSelect.run().catch(() => {
    throw new _userError.default('Command cancelled by user.');
  });
};
const promptForUpdate = async (appTypeId, opts, softwareSettings) => {
  const component = await _processComponent(appTypeId, opts.component);
  const version = await _processComponentVersion(softwareSettings, component, opts.version);
  const confirm =
  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
  opts.force || (
  // NOSONAR
  await new _enquirer.Confirm({
    message: `Are you sure you want to upgrade ${COMPONENT_NAMES[component]} to ${version}?`
  }).run().catch(() => {
    throw new _userError.default('Command cancelled by user.');
  }));
  if (confirm) {
    return {
      component,
      version
    };
  }
  throw new _userError.default('Update canceled');
};
exports.promptForUpdate = promptForUpdate;
const triggerUpdate = async variables => {
  debug('Triggering update', variables);
  const api = (0, _api.default)();
  return api.mutate({
    mutation: updateSoftwareMutation,
    variables
  });
};
exports.triggerUpdate = triggerUpdate;
const _getLatestJob = async (appId, envId) => {
  const api = (0, _api.default)();
  const result = await api.query({
    query: updateJobQuery,
    variables: {
      appId,
      envId
    },
    fetchPolicy: 'network-only'
  });
  const jobs = result.data.app?.environments?.[0]?.jobs ?? [];
  if (jobs.length) {
    return jobs.reduce((prev, current) => (prev?.createdAt || '') > (current?.createdAt || '') ? prev : current);
  }
  return null;
};
const _getCompletedJob = async (appId, envId) => {
  const latestJob = await _getLatestJob(appId, envId);
  debug('Latest job result:', latestJob);
  if (!latestJob?.inProgressLock) {
    return latestJob;
  }
  debug(`Sleep for ${UPDATE_PROGRESS_POLL_INTERVAL} seconds`);
  await (0, _promises.setTimeout)(UPDATE_PROGRESS_POLL_INTERVAL * 1000);
  return _getCompletedJob(appId, envId);
};
const getUpdateResult = async (appId, envId) => {
  debug('Getting update result', {
    appId,
    envId
  });
  const completedJob = await _getCompletedJob(appId, envId);
  const success = !completedJob || completedJob.progress?.status === 'success';
  if (success) {
    return {
      ok: true
    };
  }
  const failedStep = completedJob.progress?.steps?.find(step => step?.status === 'failed');
  const error = failedStep ? `Failed during step: ${failedStep.name}` : 'Software update failed';
  return {
    ok: false,
    errorMessage: error
  };
};
exports.getUpdateResult = getUpdateResult;
const formatSoftwareSettings = (softwareSetting, includes, format) => {
  let version = softwareSetting.current.version;
  if (softwareSetting.slug === 'wordpress' && !softwareSetting.pinned) {
    version += ' (managed updates)';
  }
  const result = {
    name: softwareSetting.name,
    slug: softwareSetting.slug,
    version
  };
  if (includes.includes('available_versions')) {
    result.available_versions = _optionsForVersion(softwareSetting).map(option => option.value);
    if (format !== 'json') {
      result.available_versions = result.available_versions.join(',');
    }
  }
  return result;
};
exports.formatSoftwareSettings = formatSoftwareSettings;