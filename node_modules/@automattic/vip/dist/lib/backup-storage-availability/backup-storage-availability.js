"use strict";

exports.__esModule = true;
exports.BackupStorageAvailability = void 0;
var _checkDiskSpace = _interopRequireDefault(require("check-disk-space"));
var _enquirer = require("enquirer");
var _os = _interopRequireDefault(require("os"));
var _path = _interopRequireDefault(require("path"));
var _shelljs = require("shelljs");
var _xdgBasedir = _interopRequireDefault(require("xdg-basedir"));
var _dockerMachineNotFoundError = require("./docker-machine-not-found-error");
var _format = require("../cli/format");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const oneGiBInBytes = 1024 * 1024 * 1024;
class BackupStorageAvailability {
  archiveSize;
  constructor(archiveSize) {
    this.archiveSize = archiveSize;
  }
  static createFromDbCopyJob(job) {
    const bytesWrittenMeta = job.metadata?.find(meta => meta?.name === 'bytesWritten');
    if (!bytesWrittenMeta?.value) {
      throw new Error('Meta not found');
    }
    return new BackupStorageAvailability(Number(bytesWrittenMeta.value));
  }
  getDockerStorageKiBRaw() {
    return (0, _shelljs.exec)(`docker run --rm alpine df -k`, {
      silent: true
    }).grep(/\/dev\/vda1/).head({
      '-n': 1
    }).replace(/\s+/g, ' ').split(' ')[3];
  }
  getDockerStorageAvailable() {
    const kiBLeft = this.getDockerStorageKiBRaw();
    if (!kiBLeft || Number.isNaN(Number(kiBLeft))) {
      throw new _dockerMachineNotFoundError.DockerMachineNotFoundError();
    }
    return Number(kiBLeft) * 1024;
  }
  bytesToHuman(bytes) {
    return (0, _format.formatMetricBytes)(bytes);
  }
  async getStorageAvailableInVipPath() {
    const vipDir = _path.default.join(_xdgBasedir.default.data ?? _os.default.tmpdir(), 'vip');
    const diskSpace = await (0, _checkDiskSpace.default)(vipDir);
    return diskSpace.free;
  }
  getReserveSpace() {
    return oneGiBInBytes;
  }
  getSqlSize() {
    // We estimated that it'd be about 3.5x the archive size.
    return this.archiveSize * 3.5;
  }
  getArchiveSize() {
    return this.archiveSize;
  }
  getStorageRequiredInMainMachine() {
    return this.getArchiveSize() + this.getSqlSize() + this.getReserveSpace();
  }
  getStorageRequiredInDockerMachine() {
    return this.getSqlSize() + this.getReserveSpace();
  }
  async isStorageAvailableInMainMachine() {
    return (await this.getStorageAvailableInVipPath()) > this.getStorageRequiredInMainMachine();
  }
  isStorageAvailableInDockerMachine() {
    return this.getDockerStorageAvailable() > this.getStorageRequiredInDockerMachine();
  }

  // eslint-disable-next-line id-length
  async validateAndPromptDiskSpaceWarningForBackupImport() {
    const isStorageAvailable = (await this.getStorageAvailableInVipPath()) > this.getArchiveSize();
    if (!isStorageAvailable) {
      const storageRequired = this.getArchiveSize();
      const confirmPrompt = new _enquirer.Confirm({
        message: `We recommend that you have at least ${this.bytesToHuman(storageRequired)} of free space in your machine to download this database backup. Do you still want to continue with downloading the database backup?`
      });
      return {
        continue: await confirmPrompt.run(),
        isPromptShown: true
      };
    }
    return {
      continue: true,
      isPromptShown: false
    };
  }

  // eslint-disable-next-line id-length
  async validateAndPromptDiskSpaceWarningForDevEnvBackupImport() {
    let storageAvailableInMainMachinePrompted = false;

    // there's two prompts, so as long as one prompt is shown, we need to set isPromptShown
    let isPromptShown = false;
    if (!(await this.isStorageAvailableInMainMachine())) {
      const storageRequired = this.getStorageRequiredInMainMachine();
      const storageAvailableInVipPath = this.bytesToHuman(await this.getStorageAvailableInVipPath());
      const confirmPrompt = new _enquirer.Confirm({
        message: `We recommend that you have at least ${this.bytesToHuman(storageRequired)} of free space in your machine to import this database backup. We estimate that you currently have ${storageAvailableInVipPath} of space in your machine.
Do you still want to continue with importing the database backup?
`
      });
      isPromptShown = true;
      storageAvailableInMainMachinePrompted = await confirmPrompt.run();
      if (!storageAvailableInMainMachinePrompted) {
        return {
          continue: false,
          isPromptShown
        };
      }
    }
    try {
      if (!this.isStorageAvailableInDockerMachine()) {
        const storageRequired = this.getStorageRequiredInDockerMachine();
        const storageAvailableInDockerMachine = this.bytesToHuman(this.getDockerStorageAvailable());
        const confirmPrompt = new _enquirer.Confirm({
          message: `We recommend that you have at least ${this.bytesToHuman(storageRequired)} of free space in your Docker machine to import this database backup. We estimate that you currently have ${storageAvailableInDockerMachine} of space in your machine.
Do you still want to continue with importing the database backup?`
        });
        isPromptShown = true;
        return {
          continue: await confirmPrompt.run(),
          isPromptShown
        };
      }
    } catch (error) {
      if (error instanceof _dockerMachineNotFoundError.DockerMachineNotFoundError) {
        // skip storage available check
        return {
          continue: true,
          isPromptShown
        };
      }
      throw error;
    }
    return {
      continue: true,
      isPromptShown
    };
  }
}
exports.BackupStorageAvailability = BackupStorageAvailability;