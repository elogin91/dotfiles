"use strict";

exports.__esModule = true;
exports.DEFAULT_SLUG = exports.CONFIGURATION_FOLDER = void 0;
exports.addDevEnvConfigurationOptions = addDevEnvConfigurationOptions;
exports.getEnvTrackingInfo = getEnvTrackingInfo;
exports.getEnvironmentName = getEnvironmentName;
exports.getEnvironmentStartCommand = getEnvironmentStartCommand;
exports.getOptionsFromAppInfo = getOptionsFromAppInfo;
exports.getTagChoices = getTagChoices;
exports.handleCLIException = handleCLIException;
exports.postStart = postStart;
exports.printTable = printTable;
exports.processBooleanOption = processBooleanOption;
exports.processComponentOptionInput = processComponentOptionInput;
exports.processMediaRedirectDomainOption = processMediaRedirectDomainOption;
exports.processSlug = processSlug;
exports.processStringOrBooleanOption = processStringOrBooleanOption;
exports.processVersionOption = processVersionOption;
exports.promptForArguments = promptForArguments;
exports.promptForBoolean = promptForBoolean;
exports.promptForComponent = promptForComponent;
exports.promptForMultisite = promptForMultisite;
exports.promptForPhpVersion = promptForPhpVersion;
exports.promptForText = promptForText;
exports.promptForWordPress = promptForWordPress;
exports.resolvePath = resolvePath;
exports.resolvePhpVersion = resolvePhpVersion;
exports.setIsTTY = setIsTTY;
exports.validateDependencies = void 0;
var _chalk = _interopRequireDefault(require("chalk"));
var _child_process = require("child_process");
var _debug = _interopRequireDefault(require("debug"));
var _enquirer = require("enquirer");
var _formatters = _interopRequireDefault(require("lando/lib/formatters"));
var _nodeFs = require("node:fs");
var _nodeOs = require("node:os");
var _path = _interopRequireDefault(require("path"));
var _shelljs = require("shelljs");
var _devEnvironmentConfigurationFile = require("./dev-environment-configuration-file");
var _devEnvironmentCore = require("./dev-environment-core");
var _devEnvironmentLando = require("./dev-environment-lando");
var _devEnvironment = require("../constants/dev-environment");
var _tracker = require("../tracker");
var _userError = _interopRequireDefault(require("../user-error"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('@automattic/vip:bin:dev-environment');
const DEFAULT_SLUG = exports.DEFAULT_SLUG = 'vip-local';
const CONFIGURATION_FOLDER = exports.CONFIGURATION_FOLDER = '.wpvip';
let isStdinTTY = Boolean(process.stdin.isTTY);

/**
 * Used internally for tests
 *
 * @param {boolean} val Value to set
 */
function setIsTTY(val) {
  isStdinTTY = val;
}
const componentDisplayNames = {
  wordpress: 'WordPress',
  muPlugins: 'vip-go-mu-plugins',
  appCode: 'application code'
};
const componentDemoNames = {
  muPlugins: 'vip-go-mu-plugins',
  appCode: 'vip-go-skeleton'
};
async function handleCLIException(exception, trackKey, trackBaseInfo = {}) {
  const errorPrefix = _chalk.default.red('Error:');
  if (_devEnvironment.DEV_ENVIRONMENT_NOT_FOUND === exception.message) {
    const createCommand = _chalk.default.bold(_devEnvironment.DEV_ENVIRONMENT_FULL_COMMAND + ' create');
    const message = `Environment doesn't exist.\n\n\nTo create a new environment run:\n\n${createCommand}\n`;
    console.error(errorPrefix, message);
  } else if (exception instanceof _userError.default) {
    // User errors are handled in global error handler
    throw exception;
  } else {
    let message = exception.message;
    // if the message has already ERROR prefix we should drop it as we are adding our own cool red Error-prefix
    message = message.replace('ERROR: ', '');
    console.error(errorPrefix, message);
    if (trackKey) {
      const errorTrackingInfo = {
        ...trackBaseInfo,
        failure: message,
        stack: exception.stack
      };
      // trackEvent does not throw
      await (0, _tracker.trackEvent)(trackKey, errorTrackingInfo);
    }
    if (!process.env.DEBUG) {
      console.error(`\nPlease re-run the command with "--debug ${_chalk.default.bold('@automattic/vip:bin:dev-environment')}" appended to it and provide the stack trace on the support ticket.`);
      console.error(_chalk.default.bold('\nExample:\n'));
      console.error('vip dev-env <command> <arguments> --debug @automattic/vip:bin:dev-environment \n');
    }
    debug(exception);
  }
}
const validateDependencies = lando => {
  const now = new Date();
  (0, _devEnvironmentLando.validateDockerInstalled)(lando);
  const duration = new Date().getTime() - now.getTime();
  debug('Validation checks completed in %d ms', duration);
};
exports.validateDependencies = validateDependencies;
async function getEnvironmentName(options) {
  if (options.slug) {
    return options.slug;
  }
  if (options.app) {
    const envSuffix = options.env ? `-${options.env}` : '';
    const appName = options.app + envSuffix;
    if (options.allowAppEnv) {
      return appName;
    }
    const message = `This command does not support @app.env notation. Use '--slug=${appName}' to target the local environment.`;
    throw new _userError.default(message);
  }
  const configurationFileOptions = await (0, _devEnvironmentConfigurationFile.getConfigurationFileOptions)();
  if (configurationFileOptions.slug && configurationFileOptions.meta) {
    const slug = configurationFileOptions.slug;
    console.log(`Using environment ${_chalk.default.blue.bold(slug)} from ${_chalk.default.gray(configurationFileOptions.meta['configuration-path'])}\n`);
    return slug;
  }
  const envs = (0, _devEnvironmentCore.getAllEnvironmentNames)();
  if (envs.length === 1) {
    return envs[0];
  }
  if (envs.length > 1 && typeof options.slug !== 'string') {
    const msg = `More than one environment found: ${_chalk.default.blue.bold(envs.join(', '))}. Please re-run command with the --slug parameter for the targeted environment.`;
    throw new _userError.default(msg);
  }
  return DEFAULT_SLUG; // Fall back to the default slug if we don't have any, e.g. during the env creation purpose
}
function getEnvironmentStartCommand(slug, configurationFileOptions) {
  const isUsingConfigurationFileSlug = Object.keys(configurationFileOptions).length > 0 && configurationFileOptions.slug === slug;
  if (!slug || isUsingConfigurationFileSlug) {
    return `${_devEnvironment.DEV_ENVIRONMENT_FULL_COMMAND} start`;
  }
  return `${_devEnvironment.DEV_ENVIRONMENT_FULL_COMMAND} start --slug ${slug}`;
}
function printTable(data) {
  const formattedData = _formatters.default.formatData(data, {
    format: 'table'
  }, {
    border: false
  });
  console.log(formattedData);
}
function processComponentOptionInput(passedParam, allowLocal) {
  // cast to string
  const param = String(passedParam);
  // This is a bit of a naive check
  if (allowLocal && /[\\/]/.test(param)) {
    return {
      mode: 'local',
      dir: param
    };
  }
  return {
    mode: 'image',
    tag: param === 'demo' ? undefined : param
  };
}
function getOptionsFromAppInfo(appInfo) {
  return {
    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
    title: appInfo.environment?.name || appInfo.name || '',
    // NOSONAR
    multisite: Boolean(appInfo.environment?.isMultisite),
    mediaRedirectDomain: appInfo.environment?.primaryDomain,
    php: appInfo.environment?.php ?? '',
    wordpress: appInfo.environment?.wordpress ?? ''
  };
}

/**
 * Prompt for arguments
 *
 * @param {InstanceOptions} preselectedOptions - options to be used without prompt
 * @param {InstanceOptions} defaultOptions     - options to be used as default values for prompt
 * @param {boolean}         suppressPrompts    - supress prompts and use default values where needed
 * @return {any} instance data
 */
// eslint-disable-next-line complexity
async function promptForArguments(preselectedOptions, defaultOptions, suppressPrompts, create) {
  debug('Provided preselected', preselectedOptions, 'and default', defaultOptions);
  if (suppressPrompts) {
    preselectedOptions = {
      ...defaultOptions,
      ...preselectedOptions
    };
  } else {
    console.log(_devEnvironment.DEV_ENVIRONMENT_PROMPT_INTRO);
  }
  let multisiteText = 'Multisite';
  if (defaultOptions.title) {
    multisiteText += ` (${defaultOptions.title} ${defaultOptions.multisite ? 'IS' : 'is NOT'} multisite)`;
  }
  const instanceData = {
    wpTitle: preselectedOptions.title ?? (await promptForText('WordPress site title', defaultOptions.title ?? _devEnvironment.DEV_ENVIRONMENT_DEFAULTS.title)),
    multisite: resolveMultisite(preselectedOptions.multisite ?? (await promptForMultisite(multisiteText, defaultOptions.multisite ?? _devEnvironment.DEV_ENVIRONMENT_DEFAULTS.multisite))),
    elasticsearch: false,
    php: preselectedOptions.php ? resolvePhpVersion(preselectedOptions.php) : await promptForPhpVersion(resolvePhpVersion(defaultOptions.php ?? _devEnvironment.DEV_ENVIRONMENT_DEFAULTS.phpVersion)),
    mariadb: preselectedOptions.mariadb ?? defaultOptions.mariadb,
    mediaRedirectDomain: preselectedOptions.mediaRedirectDomain ?? '',
    wordpress: {
      mode: 'image',
      tag: ''
    },
    muPlugins: {
      mode: 'image'
    },
    appCode: {
      mode: 'image'
    },
    phpmyadmin: false,
    xdebug: false,
    xdebugConfig: preselectedOptions.xdebugConfig,
    siteSlug: '',
    mailpit: false,
    photon: false,
    cron: false
  };
  const promptLabels = {
    xdebug: 'XDebug',
    phpmyadmin: 'phpMyAdmin',
    mailpit: 'Mailpit',
    photon: 'Photon',
    cron: 'Cron'
  };
  if (create && !instanceData.mediaRedirectDomain && defaultOptions.mediaRedirectDomain) {
    const mediaRedirectPromptText = `Would you like to redirect to ${defaultOptions.mediaRedirectDomain} for missing media files?`;
    const setMediaRedirectDomain = await promptForBoolean(mediaRedirectPromptText, true);
    if (setMediaRedirectDomain) {
      instanceData.mediaRedirectDomain = defaultOptions.mediaRedirectDomain;
    }
  }
  instanceData.wordpress = await processWordPress((preselectedOptions.wordpress ?? '').toString(), (defaultOptions.wordpress ?? '').toString());
  for (const component of _devEnvironment.DEV_ENVIRONMENT_COMPONENTS) {
    const option = (preselectedOptions[component] ?? '').toString();
    const defaultValue = (defaultOptions[component] ?? '').toString();

    // eslint-disable-next-line no-await-in-loop
    const result = await processComponent(component, option, defaultValue, suppressPrompts);
    instanceData[component] = result;
  }
  debug(`Processing elasticsearch with preselected "%s"`, preselectedOptions.elasticsearch);
  if ('elasticsearch' in preselectedOptions) {
    instanceData.elasticsearch = Boolean(preselectedOptions.elasticsearch);
  } else {
    instanceData.elasticsearch = await promptForBoolean('Enable Elasticsearch (needed by Enterprise Search)?', Boolean(defaultOptions.elasticsearch));
  }
  const services = ['phpmyadmin', 'xdebug', 'mailpit', 'photon', 'cron'];
  for (const service of services) {
    if (service in instanceData) {
      const preselected = preselectedOptions[service];
      if (preselected !== undefined) {
        instanceData[service] = preselected;
      } else {
        // eslint-disable-next-line no-await-in-loop
        instanceData[service] = await promptForBoolean(`Enable ${promptLabels[service] || service}`, Boolean(defaultOptions[service]));
      }
    }
  }
  debug('Instance data after prompts', instanceData);
  return instanceData;
}
async function processWordPress(preselectedValue, defaultValue) {
  debug(`processing 'WordPress', with preselected/default - ${preselectedValue}/${defaultValue}`);
  let result;
  const allowLocal = false;
  const defaultObject = defaultValue ? processComponentOptionInput(defaultValue, allowLocal) : null;
  if (preselectedValue) {
    result = processComponentOptionInput(preselectedValue, allowLocal);
  } else {
    result = await promptForWordPress(defaultObject);
  }
  const versions = await (0, _devEnvironmentCore.getVersionList)();
  if (versions.length) {
    versions.sort((before, after) => before.tag < after.tag ? 1 : -1);
    const match = versions.find(({
      tag
    }) => tag === result.tag);
    if (typeof match === 'undefined') {
      throw new _userError.default(`Unknown or unsupported WordPress version: ${result.tag}.`);
    }
  }
  debug(result);
  return result;
}
async function processComponent(component, preselectedValue, defaultValue, suppressPrompts = false) {
  debug(`processing a component '${component}', with preselected/default - ${preselectedValue}/${defaultValue}`);
  let result;
  const allowLocal = true;
  const defaultObject = defaultValue ? processComponentOptionInput(defaultValue, allowLocal) : null;
  if (preselectedValue) {
    result = processComponentOptionInput(preselectedValue, allowLocal);
    if (!suppressPrompts) {
      console.log(`${_chalk.default.green('✓')} Path to your local ${componentDisplayNames[component]}: ${preselectedValue}`);
    }
  } else {
    result = await promptForComponent(component, allowLocal, defaultObject);
  }
  debug(result);
  while ('local' === result.mode) {
    const resolvedPath = resolvePath(result.dir ?? '');
    result.dir = resolvedPath;
    const {
      result: isPathValid,
      message
    } = validateLocalPath(component, resolvedPath);
    if (isPathValid) {
      break;
    } else if (isStdinTTY) {
      console.log(_chalk.default.yellow('Warning:'), message);
      // eslint-disable-next-line no-await-in-loop
      result = await promptForComponent(component, allowLocal, defaultObject);
    } else {
      throw new Error(message);
    }
  }
  return result;
}
function validateLocalPath(component, providedPath) {
  if (!isNonEmptyDirectory(providedPath)) {
    const message = `Provided path "${providedPath}" does not point to a valid or existing directory.`;
    return {
      result: false,
      message
    };
  }
  if (component === 'appCode') {
    const files = ['languages', 'plugins', 'themes', 'private', 'images', 'client-mu-plugins', 'vip-config'];
    const missingFiles = [];
    for (const file of files) {
      const filePath = _path.default.resolve(providedPath, file);
      if (!(0, _nodeFs.existsSync)(filePath)) {
        missingFiles.push(file);
      }
    }
    if (missingFiles.length > 0) {
      // eslint-disable-next-line max-len
      const message = `Provided path "${providedPath}" is missing following files/folders: ${missingFiles.join(', ')}. Learn more: https://docs.wpvip.com/wordpress-skeleton/`;
      return {
        result: false,
        message
      };
    }
  }
  return {
    result: true,
    message: ''
  };
}
function isNonEmptyDirectory(directoryPath) {
  const isDirectory = directoryPath && (0, _nodeFs.existsSync)(directoryPath) && (0, _nodeFs.lstatSync)(directoryPath).isDirectory();
  const isEmpty = isDirectory ? (0, _nodeFs.readdirSync)(directoryPath).length === 0 : true;
  return !isEmpty && isDirectory;
}
function resolvePath(input) {
  // Resolve does not do ~ reliably
  const resolvedPath = input.replace(/^~/, (0, _nodeOs.homedir)());
  // And resolve to handle relative paths
  return _path.default.resolve(resolvedPath);
}
async function promptForText(message, initial) {
  let result = {
    input: initial
  };
  if (isStdinTTY) {
    const nonEmptyValidator = value => {
      if ((value || '').trim()) {
        return true;
      }
      return 'value needs to be provided';
    };
    result = await (0, _enquirer.prompt)({
      type: 'input',
      name: 'input',
      message,
      initial,
      validate: nonEmptyValidator
    });
  }
  return (result.input || '').trim();
}
const multisiteOptions = ['subdomain', 'subdirectory'];
async function promptForMultisite(message, initial) {
  // `undefined` is used here only because our tests need overhauling
  let result = {
    input: initial
  };
  if (isStdinTTY) {
    result = await (0, _enquirer.prompt)({
      type: 'input',
      name: 'input',
      message,
      initial
    });
  }
  let input = (result?.input ?? initial).toString().trim();
  const allowedOptions = [...FALSE_OPTIONS, ...TRUE_OPTIONS, ...multisiteOptions, 'none'];
  if (!allowedOptions.includes(input) && isStdinTTY) {
    const select = new _enquirer.Select({
      message: `Please choose a valid option for multisite:`,
      choices: [...multisiteOptions, 'false']
    });
    input = await select.run();
  }
  return processStringOrBooleanOption(input);
}
function promptForBoolean(message, initial) {
  if (isStdinTTY) {
    const confirm = new _enquirer.Confirm({
      message,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment
      initial: initial // TS definition is wrong, so we need to bypass it to show the correct hint.
    });
    return confirm.run();
  }
  return Promise.resolve(initial);
}
function resolveMultisite(value) {
  const isMultisiteOption = val => typeof val === 'string' && multisiteOptions.includes(val) || typeof val === 'boolean';
  return isMultisiteOption(value) ? value : _devEnvironment.DEV_ENVIRONMENT_DEFAULTS.multisite;
}
function resolvePhpVersion(version) {
  // It is painful to rewrite tests :-(
  if (version === '') {
    return '';
  }
  debug(`Resolving PHP version %j`, version);
  let result;
  if (!(version in _devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS)) {
    const images = Object.values(_devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS);
    const image = images.find(value => value.image === version);
    if (image) {
      result = image.image;
    } else {
      throw new _userError.default(`Unknown or unsupported PHP version: ${version}.`);
    }
  } else {
    result = _devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS[version].image;
  }
  debug('Resolved PHP image: %j', result);
  return result;
}
async function promptForPhpVersion(initialValue) {
  debug(`Prompting for PHP version, preselected option is ${initialValue}`);
  let answer = initialValue;
  if (isStdinTTY) {
    const choices = [];
    Object.keys(_devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS).forEach(version => {
      const phpImage = _devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS[version];
      choices.push({
        message: phpImage.label,
        value: version
      });
    });
    const images = Object.values(_devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS);
    let initial = images.findIndex(version => version.image === initialValue);
    if (initial === -1) {
      choices.push({
        message: initialValue,
        value: initialValue
      });
      initial = choices.length - 1;
    }
    const select = new _enquirer.Select({
      message: 'PHP version to use',
      choices,
      initial
    });
    answer = await select.run();
  }
  return resolvePhpVersion(answer);
}
async function promptForWordPress(defaultObject) {
  debug(`Prompting for wordpress with default:`, defaultObject);
  const componentDisplayName = componentDisplayNames.wordpress;
  const messagePrefix = `${componentDisplayName} - `;

  // image with selection
  const tagChoices = await getTagChoices();
  if (typeof defaultObject === 'string' && !tagChoices.find(choice => choice.value === defaultObject)) {
    throw new Error(`Unknown or unsupported WordPress version: ${defaultObject}.`);
  }
  let option = typeof defaultObject === 'string' ? defaultObject : defaultObject?.tag ?? tagChoices[0].value;
  if (isStdinTTY) {
    const message = `${messagePrefix}Which version would you like`;
    const selectTag = new _enquirer.Select({
      message,
      choices: tagChoices,
      initial: option
    });
    option = await selectTag.run();
  }
  return {
    mode: 'image',
    tag: option
  };
}
async function promptForComponent(component, allowLocal, defaultObject) {
  debug(`Prompting for ${component} with default:`, defaultObject);
  const componentDisplayName = componentDisplayNames[component] || component;
  const componentDemoName = componentDemoNames[component];
  const modChoices = [];
  if (allowLocal) {
    modChoices.push({
      message: `Custom - Path to a locally cloned ${componentDisplayName} directory`,
      value: 'local'
    });
  }
  modChoices.push({
    message: `Demo - Automatically fetched ${componentDemoName}`,
    value: 'image'
  });
  let initialMode = 'image';
  if ('appCode' === component && isStdinTTY) {
    initialMode = 'local';
  }
  if (defaultObject?.mode) {
    initialMode = defaultObject.mode;
  }
  let modeResult = initialMode;
  const selectMode = modChoices.length > 1;
  if (selectMode && isStdinTTY) {
    const initialModeIndex = modChoices.findIndex(choice => choice.value === initialMode);
    const select = new _enquirer.Select({
      message: `How would you like to source ${componentDisplayName}`,
      choices: modChoices,
      initial: initialModeIndex
    });
    modeResult = await select.run();
  }
  debug(modeResult);
  const messagePrefix = selectMode ? '\t' : `${componentDisplayName} - `;
  if ('local' === modeResult) {
    const directoryPath = await promptForText(`${messagePrefix}What is a path to your local ${componentDisplayName}`, defaultObject?.dir ?? '');
    return {
      mode: modeResult,
      dir: directoryPath
    };
  }

  // image
  return {
    mode: modeResult
  };
}
const FALSE_OPTIONS = ['false', 'no', 'n', '0'];
const TRUE_OPTIONS = ['true', 'yes', 'y', '1'];
function processBooleanOption(value) {
  if (!value) {
    return false;
  }

  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  return !FALSE_OPTIONS.includes(value.toString().toLowerCase()); // NOSONAR
}
function processMediaRedirectDomainOption(value) {
  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  const val = (value ?? '').toString();
  if (FALSE_OPTIONS.includes(val.toLowerCase())) {
    return '';
  }
  if (TRUE_OPTIONS.includes(val.toLowerCase())) {
    throw new _userError.default('Media redirect domain must be a domain name or an URL');
  }
  return val;
}
function processStringOrBooleanOption(value) {
  if (typeof value === 'boolean') {
    return value;
  }
  if (!value || FALSE_OPTIONS.includes(value.toLowerCase())) {
    return false;
  }
  if (TRUE_OPTIONS.includes(value.toLowerCase())) {
    return true;
  }
  return value;
}
function processSlug(value) {
  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  return (value ?? '').toString().toLowerCase();
}
function processVersionOption(value) {
  if (typeof value === 'string' || typeof value === 'number') {
    if (!isNaN(value) && Number(value) % 1 === 0) {
      return parseFloat(value).toFixed(1);
    }
  }
  return value?.toString() ?? '';
}
const phpVersionsSupported = Object.keys(_devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS).join(', ');
function addDevEnvConfigurationOptions(command) {
  // We leave the third parameter to undefined on some because the defaults are handled in preProcessInstanceData()
  return command.option('wordpress', 'Manage the version of WordPress. Accepts a string value for major versions (6.x). Defaults to the most recent version of WordPress.', undefined, processVersionOption).option(['u', 'mu-plugins'], 'Manage the source for VIP MU plugins. Accepts "demo" (default) for a read-only image of the staging branch, or a path to a built copy of VIP MU plugins on the local machine.').option('app-code', 'Manage the source for application code. Accepts "demo" (default) for a read-only image of WordPress VIP skeleton application code, or a path to a VIP formatted application repo on the local machine.').option('phpmyadmin', 'Enable or disable phpMyAdmin, disabled by default. Accepts "y" (default value) to enable or "n" to disable. When enabled, refer to the value of "PHPMYADMIN URLS" in the information output for a local environment for the URL to access phpMyAdmin.', undefined, processBooleanOption).option('xdebug', 'Enable or disable XDebug, disabled by default. Accepts "y" (default value) to enable or "n" to disable.', undefined, processBooleanOption).option('xdebug_config', 'Override some default configuration settings for Xdebug. Accepts a string value that is assigned to the XDEBUG_CONFIG environment variable.').option('elasticsearch', 'Enable or disable Elasticsearch (required by Enterprise Search), disabled by default. Accepts "y" (default value) to enable or "n" to disable.', undefined, processBooleanOption).option(['r', 'media-redirect-domain'], 'Configure media files to be proxied from a VIP Platform environment. Accepts a string value for the primary domain of the VIP Platform environment or "n" to disable the media proxy.', undefined, processMediaRedirectDomainOption).option('php', `Manage the version of PHP. Accepts a string value for minor versions: ${phpVersionsSupported}`, undefined, processVersionOption).option('cron', 'Enable or disable cron, disabled by default. Accepts "y" (default value) to enable or "n" to disable.', undefined, processBooleanOption).option(['A', 'mailpit'], 'Enable or disable Mailpit, disabled by default. Accepts "y" (default value) to enable or "n" to disable.', undefined, processBooleanOption).option(['H', 'photon'], 'Enable or disable Photon, disabled by default. Accepts "y" (default value) to enable or "n" to disable.', undefined, processBooleanOption);
}

/**
 * Provides the list of tag choices for selection
 */
async function getTagChoices() {
  let versions = await (0, _devEnvironmentCore.getVersionList)();
  if (versions.length < 1) {
    versions = [{
      ref: '6.1.1',
      tag: '6.1',
      cacheable: true,
      locked: true,
      prerelease: false
    }, {
      ref: '6.0.3',
      tag: '6.0',
      cacheable: true,
      locked: true,
      prerelease: false
    }, {
      ref: '5.9.5',
      tag: '5.9',
      cacheable: true,
      locked: true,
      prerelease: false
    }];
  }
  return versions.map(version => {
    let mapping;
    const tagFormatted = version.tag.padEnd(8 - version.tag.length);
    const prerelease = version.prerelease ? '(Pre-Release)' : '';
    if (version.tag !== version.ref) {
      mapping = `→ ${prerelease} ${version.ref}`;
    } else {
      mapping = '';
    }
    return {
      name: version.tag,
      message: `${tagFormatted} ${mapping}`,
      value: version.tag
    };
  });
}
function getEnvTrackingInfo(slug) {
  try {
    const envData = (0, _devEnvironmentCore.readEnvironmentData)(slug);
    const result = {
      slug
    };
    for (const key of Object.keys(envData)) {
      // track doesn't like camelCase
      const snakeCasedKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
      const value = _devEnvironment.DEV_ENVIRONMENT_COMPONENTS_WITH_WP.includes(key) ? JSON.stringify(envData[key]) : envData[key];
      result[snakeCasedKey] = value;
    }
    result.php = result.php.replace(/^[^:]+:/, '');
    return result;
  } catch (err) {
    return {
      slug
    };
  }
}
function postStart(slug, options) {
  if (options.openVSCode) {
    launchVSCode(slug);
  }
}
const launchVSCode = slug => {
  const workspacePath = (0, _devEnvironmentCore.getVSCodeWorkspacePath)(slug);
  if ((0, _nodeFs.existsSync)(workspacePath)) {
    console.log('VS Code workspace already exists, skipping creation.');
  } else {
    (0, _devEnvironmentCore.generateVSCodeWorkspace)(slug);
    console.log('VS Code workspace generated');
  }
  const vsCodeExecutable = getVSCodeExecutable();
  if (vsCodeExecutable) {
    (0, _child_process.spawn)(vsCodeExecutable, [workspacePath], {
      shell: process.platform === 'win32'
    });
  } else {
    console.log(`VS Code was not detected in the expected path. VS Code Workspace file location:\n${workspacePath}`);
  }
};
const getVSCodeExecutable = () => {
  const candidates = ['code', 'code-insiders', 'codium'];
  for (const candidate of candidates) {
    const result = (0, _shelljs.which)(candidate);
    if (result) {
      debug(`Found ${candidate} in path`);
      return candidate;
    }
    debug(`Could not find ${candidate} in path`);
  }
  return null;
};