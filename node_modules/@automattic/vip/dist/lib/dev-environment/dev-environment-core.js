"use strict";

exports.__esModule = true;
exports.createEnvironment = createEnvironment;
exports.destroyEnvironment = destroyEnvironment;
exports.doesEnvironmentExist = doesEnvironmentExist;
exports.exec = exec;
exports.fetchVersionList = fetchVersionList;
exports.generateVSCodeWorkspace = generateVSCodeWorkspace;
exports.getAllEnvironmentNames = getAllEnvironmentNames;
exports.getApplicationInformation = getApplicationInformation;
exports.getEnvironmentPath = getEnvironmentPath;
exports.getVSCodeWorkspacePath = getVSCodeWorkspacePath;
exports.getVersionList = getVersionList;
exports.importMediaPath = importMediaPath;
exports.printAllEnvironmentsInfo = printAllEnvironmentsInfo;
exports.printEnvironmentInfo = printEnvironmentInfo;
exports.readEnvironmentData = readEnvironmentData;
exports.resolveImportPath = resolveImportPath;
exports.showLogs = showLogs;
exports.startEnvironment = startEnvironment;
exports.stopEnvironment = stopEnvironment;
exports.updateEnvironment = updateEnvironment;
exports.writeEnvironmentData = writeEnvironmentData;
var _chalk = _interopRequireDefault(require("chalk"));
var _copyDir = _interopRequireDefault(require("copy-dir"));
var _debug = _interopRequireDefault(require("debug"));
var _ejs = _interopRequireDefault(require("ejs"));
var _enquirer = require("enquirer");
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _nodeFs = _interopRequireDefault(require("node:fs"));
var _nodePath = _interopRequireDefault(require("node:path"));
var _semver = _interopRequireDefault(require("semver"));
var _uuid = require("uuid");
var _xdgBasedir = _interopRequireDefault(require("xdg-basedir"));
var _devEnvironmentCli = require("./dev-environment-cli");
var _devEnvironmentLando = require("./dev-environment-lando");
var _app = _interopRequireDefault(require("../api/app"));
var _software = require("../config/software");
var _devEnvironment = require("../constants/dev-environment");
var _proxyAgent = require("../http/proxy-agent");
var _searchAndReplace = require("../search-and-replace");
var _userError = _interopRequireDefault(require("../user-error"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const debug = (0, _debug.default)('@automattic/vip:bin:dev-environment');
const landoFileTemplatePath = _nodePath.default.join(__dirname, '..', '..', '..', 'assets', 'dev-env.lando.template.yml.ejs');
const nginxFileTemplatePath = _nodePath.default.join(__dirname, '..', '..', '..', 'assets', 'dev-env.nginx.template.conf.ejs');
const landoFileName = '.lando.yml';
const landoBackupFileName = '.lando.backup.yml';
const nginxFileName = 'extra.conf';
const instanceDataFileName = 'instance_data.json';
const uploadPathString = 'uploads';
const nginxPathString = 'nginx';
function xdgDataDirectory() {
  if (_xdgBasedir.default.data) {
    return _xdgBasedir.default.data;
  }

  // This should not happen. If it does, this means that the system was unable to find user's home directory.
  // If so, this does not leave us many options as to where to store the data.
  throw new Error('Unable to determine data directory.');
}
async function startEnvironment(lando, slug, options) {
  debug('Will start an environment', slug);
  const instancePath = getEnvironmentPath(slug);
  debug('Instance path for', slug, 'is:', instancePath);
  const environmentExists = _nodeFs.default.existsSync(instancePath);
  if (!environmentExists) {
    throw new Error(_devEnvironment.DEV_ENVIRONMENT_NOT_FOUND);
  }
  let updated = false;
  if (!options.skipWpVersionsCheck) {
    updated = await maybeUpdateWordPressImage(lando, slug);
  }
  updated = updated || (await maybeUpdateVersion(lando, slug));
  if (options.skipRebuild && !updated) {
    await (0, _devEnvironmentLando.landoStart)(lando, instancePath);
  } else {
    await (0, _devEnvironmentLando.landoRebuild)(lando, instancePath);
  }
  await printEnvironmentInfo(lando, slug, {
    extended: false
  });
}
async function stopEnvironment(lando, slug) {
  debug('Will stop an environment', slug);
  const instancePath = getEnvironmentPath(slug);
  debug('Instance path for', slug, 'is:', instancePath);
  const environmentExists = _nodeFs.default.existsSync(instancePath);
  if (!environmentExists) {
    throw new Error(_devEnvironment.DEV_ENVIRONMENT_NOT_FOUND);
  }
  await (0, _devEnvironmentLando.landoStop)(lando, instancePath);
}
async function createEnvironment(lando, instanceData) {
  const slug = instanceData.siteSlug;
  debug('Will process an environment', slug, 'with instanceData for creation: ', instanceData);
  const instancePath = getEnvironmentPath(slug);
  debug('Instance path for', slug, 'is:', instancePath);
  const alreadyExists = _nodeFs.default.existsSync(instancePath);
  if (alreadyExists) {
    throw new Error('Environment already exists.');
  }
  const preProcessedInstanceData = preProcessInstanceData(instanceData);
  debug('Will create an environment', slug, 'with instanceData: ', preProcessedInstanceData);
  await prepareLandoEnv(lando, preProcessedInstanceData, instancePath);
}
async function updateEnvironment(lando, instanceData) {
  const slug = instanceData.siteSlug;
  debug('Will process an environment', slug, 'with instanceData for updating: ', instanceData);
  const instancePath = getEnvironmentPath(slug);
  debug('Instance path for', slug, 'is:', instancePath);
  const alreadyExists = _nodeFs.default.existsSync(instancePath);
  if (!alreadyExists) {
    throw new Error("Environment doesn't exist.");
  }
  const preProcessedInstanceData = preProcessInstanceData(instanceData);
  debug('Will create an environment', slug, 'with instanceData: ', preProcessedInstanceData);
  await prepareLandoEnv(lando, preProcessedInstanceData, instancePath);
}
function preProcessInstanceData(instanceData) {
  const newInstanceData = {
    ...instanceData
  };
  if (instanceData.mediaRedirectDomain && !/^http/.exec(instanceData.mediaRedirectDomain)) {
    // We need to make sure the redirect is an absolute path
    newInstanceData.mediaRedirectDomain = `https://${instanceData.mediaRedirectDomain}`;
  }

  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
  newInstanceData.elasticsearch = instanceData.elasticsearch || false; // NOSONAR

  newInstanceData.php = instanceData.php || _devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS[Object.keys(_devEnvironment.DEV_ENVIRONMENT_PHP_VERSIONS)[0]].image;

  // FIXME: isNaN supports only number in TypeScript, actually, because isNaN('123') returns false despite being a string
  if (isNaN(instanceData.wordpress.tag)) {
    newInstanceData.wordpress.tag = 'trunk';
  }
  if (!newInstanceData.xdebugConfig) {
    newInstanceData.xdebugConfig = '';
  }
  if (!newInstanceData.xdebug) {
    newInstanceData.xdebug = false;
  }
  if (!newInstanceData.phpmyadmin) {
    newInstanceData.phpmyadmin = false;
  }
  if (!newInstanceData.photon) {
    newInstanceData.photon = false;
  }
  if (!newInstanceData.cron) {
    newInstanceData.cron = false;
  }

  // Mailpit migration
  newInstanceData.mailpit ??= false;

  // MariaDB migration
  if (!newInstanceData.mariadb) {
    newInstanceData.mariadb = undefined;
  }

  // newInstanceData
  newInstanceData.autologinKey = (0, _uuid.v4)();
  newInstanceData.version = _devEnvironment.DEV_ENVIRONMENT_VERSION;
  return newInstanceData;
}
async function destroyEnvironment(lando, slug, removeFiles) {
  debug('Will destroy an environment', slug);
  const instancePath = getEnvironmentPath(slug);
  debug('Instance path for', slug, 'is:', instancePath);
  const environmentExists = await doesEnvironmentExist(instancePath);
  if (!environmentExists) {
    throw new Error(_devEnvironment.DEV_ENVIRONMENT_NOT_FOUND);
  }
  const landoFilePath = _nodePath.default.join(instancePath, landoFileName);
  if (_nodeFs.default.existsSync(landoFilePath)) {
    debug('Lando file exists, will lando destroy.');
    await (0, _devEnvironmentLando.landoDestroy)(lando, instancePath);
  } else {
    debug("Lando file doesn't exist, skipping lando destroy.");
  }
  if (removeFiles) {
    await _nodeFs.default.promises.rm(instancePath, {
      recursive: true
    });
    console.log(`${_chalk.default.green('âœ“')} Environment files deleted successfully.`);
  }
}
async function printAllEnvironmentsInfo(lando, options) {
  const allEnvNames = getAllEnvironmentNames();
  debug('Will print info for all environments. Names found: ', allEnvNames);
  console.log('Found ' + _chalk.default.bold(allEnvNames.length) + ' environments' + (allEnvNames.length ? ':' : '.'));
  for (const envName of allEnvNames) {
    try {
      console.log('\n');
      // eslint-disable-next-line no-await-in-loop
      await printEnvironmentInfo(lando, envName, options);
    } catch (error) {
      if (error instanceof _userError.default) {
        console.warn('\nWARNING: "%s" is not a valid environment\n', envName);
      } else {
        throw error;
      }
    }
  }
}
function parseComponentForInfo(component) {
  if (component.mode === 'local') {
    return component.dir ?? '';
  }

  // Environments created by the old code will have `component.tag` set to `demo` instead of `undefined`.
  if (component.tag === 'demo' || component.tag === 'latest') {
    component.tag = undefined;
  }
  return component.tag ?? '[demo-image]';
}
async function showLogs(lando, slug, options = {}) {
  debug('Will display logs command on env', slug, 'with options', options);
  const instancePath = getEnvironmentPath(slug);
  debug('Instance path for', slug, 'is:', instancePath);
  if (options.service) {
    const appInfo = await (0, _devEnvironmentLando.landoInfo)(lando, instancePath);
    if (!appInfo.services.includes(options.service)) {
      throw new _userError.default(`Service '${options.service}' not found. Please choose from one: ${appInfo.services.toString()}`);
    }
  }
  return (0, _devEnvironmentLando.landoLogs)(lando, instancePath, options);
}
async function printEnvironmentInfo(lando, slug, options) {
  debug('Will get info for an environment', slug);
  const instancePath = getEnvironmentPath(slug);
  debug('Instance path for', slug, 'is:', instancePath);
  const environmentExists = await doesEnvironmentExist(instancePath);
  if (!environmentExists) {
    throw new _userError.default(_devEnvironment.DEV_ENVIRONMENT_NOT_FOUND);
  }
  const environmentData = readEnvironmentData(slug);
  const appInfo = await (0, _devEnvironmentLando.landoInfo)(lando, instancePath, {
    suppressWarnings: Boolean(options.suppressWarnings),
    autologinKey: environmentData.autologinKey
  });
  if (options.extended) {
    appInfo.title = environmentData.wpTitle;
    appInfo.multisite = Boolean(environmentData.multisite);
    appInfo.php = environmentData.php.split(':')[1];
    let xdebug = environmentData.xdebug ? 'enabled' : 'disabled';
    if (environmentData.xdebug && environmentData.xdebugConfig) {
      xdebug += ' (with additional configuration)';
    }
    appInfo.xdebug = xdebug;
    appInfo.cron = environmentData.cron ? 'enabled' : 'disabled';
    appInfo.wordpress = parseComponentForInfo(environmentData.wordpress);
    appInfo['Mu plugins'] = parseComponentForInfo(environmentData.muPlugins);
    appInfo['App Code'] = parseComponentForInfo(environmentData.appCode);
    if (environmentData.mediaRedirectDomain) {
      appInfo['Media Redirect'] = environmentData.mediaRedirectDomain;
    }
  }
  (0, _devEnvironmentCli.printTable)(appInfo);
}
function exec(lando, slug, args, options = {}) {
  debug('Will run a wp command on env', slug, 'with args', args, ' and options', options);
  const instancePath = getEnvironmentPath(slug);
  debug('Instance path for', slug, 'is:', instancePath);
  const [command, ...commandArgs] = args;
  return (0, _devEnvironmentLando.landoExec)(lando, instancePath, command, commandArgs, options);
}
async function doesEnvironmentExist(instancePath) {
  debug('Will check for environment at', instancePath);
  const file = _nodePath.default.join(instancePath, instanceDataFileName);
  try {
    const stats = await _nodeFs.default.promises.stat(file);
    return stats.isFile();
  } catch (err) {
    return false;
  }
}
function readEnvironmentData(slug) {
  debug('Will try to get instance data for environment', slug);
  const instancePath = getEnvironmentPath(slug);
  const instanceDataTargetPath = _nodePath.default.join(instancePath, instanceDataFileName);
  let instanceDataString;
  let instanceData;
  try {
    instanceDataString = _nodeFs.default.readFileSync(instanceDataTargetPath, 'utf8');
  } catch (error) {
    const err = error;
    throw new _userError.default(`There was an error reading file "${instanceDataTargetPath}": ${err.message}.`, {
      cause: error
    });
  }
  try {
    instanceData = JSON.parse(instanceDataString);
  } catch (error) {
    const err = error;
    throw new _userError.default(`There was an error parsing file "${instanceDataTargetPath}": ${err.message}. You may need to recreate the environment.`, {
      cause: error
    });
  }

  /**
   ***********************************
   * BACKWARDS COMPATIBILITY SECTION
   **********************************
   */

  // REMOVEME after the wheel of time spins around few times
  if (instanceData.enterpriseSearchEnabled || instanceData.elasticsearchEnabled) {
    // enterpriseSearchEnabled and elasticsearchEnabled was renamed to elasticsearch
    instanceData.elasticsearch = instanceData.enterpriseSearchEnabled || instanceData.elasticsearchEnabled;
  }

  // REMOVEME after the wheel of time spins around few times
  if (instanceData.clientCode) {
    // clientCode was renamed to appCode
    instanceData.appCode = instanceData.clientCode;
  }
  return instanceData;
}

/**
 * Writes the instance data.
 *
 * @param {string}       slug Env slug
 * @param {InstanceData} data instance data
 * @return {Promise<void>} Promise
 */
function writeEnvironmentData(slug, data) {
  debug('Will try to write instance data for environment', slug);
  const instancePath = getEnvironmentPath(slug);
  const instanceDataTargetPath = _nodePath.default.join(instancePath, instanceDataFileName);
  return _nodeFs.default.promises.writeFile(instanceDataTargetPath, JSON.stringify(data, null, 2));
}
async function prepareLandoEnv(lando, instanceData, instancePath) {
  const templateData = {
    ...instanceData,
    domain: lando.config.domain
  };
  const landoFile = await _ejs.default.renderFile(landoFileTemplatePath, templateData);
  const nginxFile = await _ejs.default.renderFile(nginxFileTemplatePath, templateData);
  const instanceDataFile = JSON.stringify(instanceData);
  const landoFileTargetPath = _nodePath.default.join(instancePath, landoFileName);
  const landoBackupFileTargetPath = _nodePath.default.join(instancePath, landoBackupFileName);
  const nginxFolderPath = _nodePath.default.join(instancePath, nginxPathString);
  const nginxFileTargetPath = _nodePath.default.join(nginxFolderPath, nginxFileName);
  const instanceDataTargetPath = _nodePath.default.join(instancePath, instanceDataFileName);
  await _nodeFs.default.promises.mkdir(instancePath, {
    recursive: true
  });
  await _nodeFs.default.promises.mkdir(nginxFolderPath, {
    recursive: true
  });
  try {
    await _nodeFs.default.promises.rename(landoFileTargetPath, landoBackupFileTargetPath);
    console.log(`Backup of ${landoFileName} was created in ${landoBackupFileTargetPath}`);
  } catch (err) {
    // If the file doesn't exist, that's fine. Otherwise, throw the error.
    if ('ENOENT' !== err.code) {
      throw err;
    }
  }
  await Promise.all([_nodeFs.default.promises.writeFile(landoFileTargetPath, landoFile), _nodeFs.default.promises.writeFile(nginxFileTargetPath, nginxFile), _nodeFs.default.promises.writeFile(instanceDataTargetPath, instanceDataFile)]);
  debug(`Lando file created in ${landoFileTargetPath}`);
  debug(`Nginx file created in ${nginxFileTargetPath}`);
  debug(`Instance data file created in ${instanceDataTargetPath}`);
}
function getAllEnvironmentNames() {
  const mainEnvironmentPath = xdgDataDirectory();
  const baseDir = _nodePath.default.join(mainEnvironmentPath, 'vip', 'dev-environment');
  const doWeHaveAnyEnvironment = _nodeFs.default.existsSync(baseDir);
  let envNames = [];
  if (doWeHaveAnyEnvironment) {
    const files = _nodeFs.default.readdirSync(baseDir);
    envNames = files.filter(file => {
      const fullPath = _nodePath.default.join(baseDir, file);
      return _nodeFs.default.lstatSync(fullPath).isDirectory();
    });
  }
  return envNames;
}
function getEnvironmentPath(name) {
  if (!name) {
    throw new Error('Name was not provided');
  }
  const mainEnvironmentPath = xdgDataDirectory();
  return _nodePath.default.join(mainEnvironmentPath, 'vip', 'dev-environment', String(name));
}
async function getApplicationInformation(appId, envType) {
  // $FlowFixMe: gql template is not supported by flow
  const fieldsQuery = `
		id,
		name,
		repository {
			htmlUrl,
			fullName
		},
		environments {
			id,
			name,
			type,
			branch,
			isMultisite,
			primaryDomain {
				name
			},
			softwareSettings {
				php {
				  ...Software
				}
				wordpress {
				  ...Software
				}
			}
		}`;
  const queryResult = await (0, _app.default)(appId, fieldsQuery, _software.appQueryFragments);
  const appData = {};
  if (queryResult.id) {
    appData.id = queryResult.id;
    appData.name = queryResult.name;
    appData.repository = queryResult.repository?.htmlUrl;

    // FIXME: This is casted as AppEnvironment[] but pedantically, Parker's schema made it so that the array may contain nullable. Code-wise though, that doesn't actually happen.
    const environments = queryResult.environments ?? [];
    let envData;
    if (envType) {
      envData = environments.find(candidateEnv => candidateEnv.type === envType);
    } else if (1 === environments.length) {
      envData = environments[0];
    } else {
      const choices = environments.map(candidateEnv => candidateEnv.type);
      const {
        env
      } = await (0, _enquirer.prompt)({
        type: 'select',
        name: 'env',
        message: 'Which environment?',
        choices
      });
      envData = environments.find(candidateEnv => candidateEnv.type === env);
    }
    if (envData) {
      appData.environment = {
        name: envData.name,
        branch: envData.branch,
        type: envData.type,
        isMultisite: envData.isMultisite,
        primaryDomain: envData.primaryDomain?.name ?? '',
        php: envData.softwareSettings?.php?.current.version ?? '',
        wordpress: envData.softwareSettings?.wordpress?.current.version ?? ''
      };
    }
  }
  return appData;
}
async function resolveImportPath(slug, fileName, searchReplace, inPlace) {
  debug(`Will try to resolve path - ${fileName}`);
  let resolvedPath = (0, _devEnvironmentCli.resolvePath)(fileName);
  debug(`Filename ${fileName} resolved to ${resolvedPath}`);
  if (!_nodeFs.default.existsSync(resolvedPath)) {
    throw new _userError.default(`The provided file ${resolvedPath} does not exist or it is not valid (see "--help" for examples)`);
  }
  if (_nodeFs.default.lstatSync(resolvedPath).isDirectory()) {
    throw new _userError.default(`The provided file ${resolvedPath} is a directory. Please point to a sql file.`);
  }

  // Run Search and Replace if the --search-replace flag was provided
  if (searchReplace?.length) {
    const {
      outputFileName
    } = await (0, _searchAndReplace.searchAndReplace)(resolvedPath, searchReplace, {
      isImport: true,
      output: true,
      inPlace
    });
    if (typeof outputFileName !== 'string') {
      throw new Error('Unable to determine location of the intermediate search & replace file.');
    }
    resolvedPath = outputFileName;
  }
  return resolvedPath;
}
async function importMediaPath(slug, filePath) {
  const resolvedPath = (0, _devEnvironmentCli.resolvePath)(filePath);
  if (!_nodeFs.default.existsSync(resolvedPath) || !_nodeFs.default.lstatSync(resolvedPath).isDirectory()) {
    throw new Error('The provided path does not exist or it is not valid (see "--help" for examples)');
  }
  const environmentPath = getEnvironmentPath(slug);
  if (!(await doesEnvironmentExist(environmentPath))) {
    throw new Error(_devEnvironment.DEV_ENVIRONMENT_NOT_FOUND);
  }
  const files = _nodeFs.default.readdirSync(resolvedPath);
  if (files.includes(uploadPathString)) {
    const confirm = await (0, _enquirer.prompt)({
      type: 'confirm',
      name: 'continue',
      message: 'The provided path contains an uploads folder inside. Do you want to continue?'
    });
    if (!confirm.continue) {
      return;
    }
  }
  const uploadsPath = _nodePath.default.join(environmentPath, uploadPathString);
  console.log(`${_chalk.default.yellow('-')} Started copying files`);
  _copyDir.default.sync(resolvedPath, uploadsPath);
  console.log(`${_chalk.default.green('âœ“')} Files successfully copied to ${uploadsPath}.`);
}

/**
 * Uses the WordPress versions manifest on github.com
 * Informs the user several things:
 *   - If the WordPress image their env uses is no longer available
 *   - If there is a newer version of the WordPress version currently used
 *   - A choice to use a different image
 *
 * @param {string} slug slug
 * @return {boolean} boolean
 */
async function maybeUpdateWordPressImage(lando, slug) {
  const versions = await getVersionList();
  if (!versions.length) {
    return false;
  }
  let message;
  let envData;
  let currentWordPressTag;

  // Get the current environment configuration
  try {
    envData = readEnvironmentData(slug);
    currentWordPressTag = envData.wordpress.tag;
    if (currentWordPressTag === 'trunk') {
      return false;
    }
  } catch (err) {
    const error = err;
    // This can throw an exception if the env is build with older vip version
    if ('ENOENT' === error.code) {
      message = 'Environment was created before update was supported.\n\n';
      message += 'To update environment please destroy it and create a new one.';
    } else {
      message = `An error prevented reading the configuration of: ${slug}\n\n ${error.message}`;
    }
    await (0, _devEnvironmentCli.handleCLIException)(new Error(message));
    return false;
  }

  // sort
  versions.sort((before, after) => before.tag < after.tag ? 1 : -1);
  // Newest WordPress Image but that is not trunk
  const newestWordPressImage = versions.find(({
    tag
  }) => tag !== 'trunk');
  console.log('The most recent WordPress version available is: ' + _chalk.default.green(newestWordPressImage?.tag));

  // If the currently used version is the most up to date: exit.
  if (currentWordPressTag === newestWordPressImage?.tag) {
    console.log('Environment WordPress version is: ' + _chalk.default.green(currentWordPressTag) + '  ... ðŸ˜Ž nice! ');
    return false;
  }

  // Determine if there is an image available for the current WordPress version
  const match = versions.find(({
    tag
  }) => tag === currentWordPressTag);

  // If there is no available image for the currently installed version, give user a path to change
  if (typeof match === 'undefined') {
    console.log(`Installed WordPress: ${currentWordPressTag} has no available container image in repository. `);
    console.log('You must select a new WordPress image to continue... ');
  } else {
    console.log('Environment WordPress version is: ' + _chalk.default.yellow(`${match.tag} (${match.ref})`));
    if (envData.wordpress.doNotUpgrade) {
      return false;
    }
  }

  // Prompt the user to select a new WordPress Version
  const confirm = await (0, _enquirer.prompt)({
    type: 'select',
    name: 'upgrade',
    message: 'Would you like to upgrade WordPress? ',
    choices: ['yes', 'no', "no (don't ask anymore)"]
  });

  // If the user takes the new WP version path
  if (confirm.upgrade === 'yes') {
    console.log('Upgrading from: ' + _chalk.default.yellow(currentWordPressTag) + ' to:');

    // Select a new image
    const choice = await (0, _devEnvironmentCli.promptForWordPress)(newestWordPressImage?.tag ?? null);
    const version = versions.find(({
      tag
    }) => tag.trim() === choice.tag.trim());

    // Write new data and stage for rebuild
    // FIXME: version?.tag is possibly null. Should we throw if we can't find a version somehow?
    envData.wordpress.tag = version?.tag ?? '';
    envData.wordpress.ref = version?.ref;
    await updateEnvironment(lando, envData);
    return true;
  }
  if (confirm.upgrade === "no (don't ask anymore)") {
    const updateCommand = `vip dev-env update --slug=${slug}`;
    envData.wordpress.doNotUpgrade = true;
    console.log("We won't ask about upgrading this environment anymore.");
    console.log(`To manually upgrade please run: ${_chalk.default.yellow(updateCommand)}`);
    await updateEnvironment(lando, envData);
  }
  return false;
}
async function maybeUpdateVersion(lando, slug) {
  const envData = readEnvironmentData(slug);
  const currentVersion = envData.version;
  console.log('Current local environment version is: ' + _chalk.default.yellow(currentVersion));
  if (!currentVersion || _semver.default.lt(currentVersion, _devEnvironment.DEV_ENVIRONMENT_VERSION)) {
    envData.pullAfter = undefined;
    await updateEnvironment(lando, envData);
    console.log('Local environment version updated to: ' + _chalk.default.green(_devEnvironment.DEV_ENVIRONMENT_VERSION));
    return true;
  }
  return false;
}

/**
 * Makes a web call to raw.githubusercontent.com
 */
function fetchVersionList() {
  const url = `https://${_devEnvironment.DEV_ENVIRONMENT_RAW_GITHUB_HOST}${_devEnvironment.DEV_ENVIRONMENT_WORDPRESS_VERSIONS_URI}`;
  const proxyAgent = (0, _proxyAgent.createProxyAgent)(url);
  return (0, _nodeFetch.default)(url, {
    agent: proxyAgent ?? undefined
  }).then(res => res.json());
}

/**
 * Encapsulates the logic for determining if a file is expired by an arbitrary TTL
 *
 * @param {string} cacheFile uri of cache file
 * @param {number} ttl       time to live in seconds
 * @return {Promise<boolean>} version list expired true/false
 */
async function isVersionListExpired(cacheFile, ttl) {
  try {
    const {
      mtime: expire
    } = await _nodeFs.default.promises.stat(cacheFile);
    expire.setSeconds(expire.getSeconds() + ttl);
    return Number(new Date()) > Number(expire);
  } catch (err) {
    return true;
  }
}

/**
 * Uses a cache file to keep the version list in tow until it is ultimately outdated
 */
async function getVersionList() {
  let res;
  const mainEnvironmentPath = xdgDataDirectory();
  const cacheFilePath = _nodePath.default.join(mainEnvironmentPath, 'vip');
  const cacheFile = _nodePath.default.join(cacheFilePath, _devEnvironment.DEV_ENVIRONMENT_WORDPRESS_CACHE_KEY);
  // Handle from cache
  try {
    // If the path for the cache file doesn't exist, create it
    if (!_nodeFs.default.existsSync(cacheFilePath)) {
      await _nodeFs.default.promises.mkdir(cacheFilePath, {
        recursive: true
      });
    }

    // If the cache does not exist or has expired, refresh it
    if (await isVersionListExpired(cacheFile, _devEnvironment.DEV_ENVIRONMENT_WORDPRESS_VERSION_TTL)) {
      res = await fetchVersionList();
      await _nodeFs.default.promises.writeFile(cacheFile, JSON.stringify(res));
    }
  } catch (err) {
    // Soft error handling here, since it's still possible to use a previously cached file.
    console.log(_chalk.default.yellow('fetchWordPressVersionList failed to retrieve an updated version list'));
    debug(err);
  }

  // Try to parse the cached file if it exists.
  try {
    const data = await _nodeFs.default.promises.readFile(cacheFile, 'utf8');
    return JSON.parse(data);
  } catch (err) {
    debug(err);
    return [{
      ref: 'HEAD',
      tag: 'trunk',
      cacheable: false,
      locked: false,
      prerelease: true
    }];
  }
}

/**
 * Functions generates workspace config including the launch config
 *
 * @param {string} slug - The slug of the environment to generate workspace config for
 * @return {string} Workspace path
 */
function generateVSCodeWorkspace(slug) {
  debug('Generating VS Code Workspace');
  const location = getEnvironmentPath(slug);
  const workspacePath = getVSCodeWorkspacePath(slug);
  const instanceData = readEnvironmentData(slug);
  const pathMappings = generatePathMappings(location, instanceData);
  const folders = [{
    path: location
  }];
  if (instanceData.muPlugins.dir) {
    folders.push({
      path: instanceData.muPlugins.dir
    });
  }
  if (instanceData.appCode.dir) {
    folders.push({
      path: instanceData.appCode.dir
    });
  }
  const workspace = {
    folders,
    launch: {
      version: '0.2.0',
      configurations: [{
        name: `Debug ${slug}`,
        type: 'php',
        request: 'launch',
        port: 9003,
        pathMappings
      }]
    }
  };
  _nodeFs.default.writeFileSync(workspacePath, JSON.stringify(workspace, null, 2));
  return workspacePath;
}
const generatePathMappings = (location, instanceData) => {
  const pathMappings = {};
  if (instanceData.muPlugins.dir) {
    pathMappings['/wp/wp-content/mu-plugins'] = instanceData.muPlugins.dir;
  }
  if (instanceData.appCode.dir) {
    pathMappings['/wp/wp-content/client-mu-plugins'] = _nodePath.default.resolve(instanceData.appCode.dir, 'client-mu-plugins');
    pathMappings['/wp/wp-content/images'] = _nodePath.default.resolve(instanceData.appCode.dir, 'images');
    pathMappings['/wp/wp-content/languages'] = _nodePath.default.resolve(instanceData.appCode.dir, 'languages');
    pathMappings['/wp/wp-content/plugins'] = _nodePath.default.resolve(instanceData.appCode.dir, 'plugins');
    pathMappings['/wp/wp-content/private'] = _nodePath.default.resolve(instanceData.appCode.dir, 'private');
    pathMappings['/wp/wp-content/themes'] = _nodePath.default.resolve(instanceData.appCode.dir, 'themes');
    pathMappings['/wp/wp-content/vip-config'] = _nodePath.default.resolve(instanceData.appCode.dir, 'vip-config');
  }
  pathMappings['/wp'] = _nodePath.default.resolve(location, 'wordpress');
  return pathMappings;
};
function getVSCodeWorkspacePath(slug) {
  const location = getEnvironmentPath(slug);
  const workspacePath = _nodePath.default.join(location, `${slug}.code-workspace`);
  return workspacePath;
}