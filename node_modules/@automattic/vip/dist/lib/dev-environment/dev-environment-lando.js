"use strict";

exports.__esModule = true;
exports.bootstrapLando = bootstrapLando;
exports.checkEnvHealth = checkEnvHealth;
exports.isEnvUp = isEnvUp;
exports.landoDestroy = landoDestroy;
exports.landoExec = landoExec;
exports.landoInfo = landoInfo;
exports.landoLogs = landoLogs;
exports.landoRebuild = landoRebuild;
exports.landoShell = landoShell;
exports.landoStart = landoStart;
exports.landoStop = landoStop;
exports.validateDockerInstalled = validateDockerInstalled;
var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _bootstrap = require("lando/lib/bootstrap");
var _lando = _interopRequireDefault(require("lando/lib/lando"));
var _utils = _interopRequireDefault(require("lando/plugins/lando-core/lib/utils"));
var _build = _interopRequireDefault(require("lando/plugins/lando-tooling/lib/build"));
var _promises = require("node:dns/promises");
var _promises2 = require("node:fs/promises");
var _nodeOs = require("node:os");
var _nodePath = _interopRequireWildcard(require("node:path"));
var _semver = require("semver");
var _xdgBasedir = _interopRequireDefault(require("xdg-basedir"));
var _devEnvironmentCore = require("./dev-environment-core");
var _dockerUtils = require("./docker-utils");
var _devEnvironment = require("../constants/dev-environment");
var _userError = _interopRequireDefault(require("../user-error"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * This file will hold all the interactions with lando library
 */
const DEBUG_KEY = '@automattic/vip:bin:dev-environment';
const debug = (0, _debug.default)(DEBUG_KEY);

/**
 * @return {Promise<LandoConfig>} Lando configuration
 */
async function getLandoConfig() {
  // The path will be smth like `yarn/global/node_modules/lando/lib/lando.js`; we need the path up to `lando` (inclusive)
  const landoPath = (0, _nodePath.dirname)((0, _nodePath.dirname)(require.resolve('lando')));
  // The path will be smth like `yarn/global/node_modules/@lando/compose/index.js`; we need the path up to `@lando` (inclusive)
  const atLandoPath = (0, _nodePath.dirname)((0, _nodePath.dirname)(require.resolve('@lando/compose')));
  debug(`Getting Lando config, using paths '${landoPath}' and '${atLandoPath}' for plugins`);
  const isLandoDebugSelected = _debug.default.enabled(DEBUG_KEY);
  const isAllDebugSelected = _debug.default.enabled('"*"');
  let logLevelConsole;
  if (isAllDebugSelected) {
    logLevelConsole = 'silly';
  } else if (isLandoDebugSelected) {
    logLevelConsole = 'debug';
  } else {
    logLevelConsole = 'warn';
  }

  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
  const vipDir = _nodePath.default.join(_xdgBasedir.default.data || (0, _nodeOs.tmpdir)(), 'vip'); // NOSONAR
  const landoDir = _nodePath.default.join(vipDir, 'lando');
  const fakeHomeDir = _nodePath.default.join(landoDir, 'home');
  try {
    await (0, _promises2.mkdir)(fakeHomeDir, {
      recursive: true
    });
  } catch (err) {
    // Ignore
  }
  const config = {
    logLevelConsole,
    configSources: [_nodePath.default.join(landoDir, 'config.yml')],
    landoFile: '.lando.yml',
    preLandoFiles: ['.lando.base.yml', '.lando.dist.yml', '.lando.upstream.yml'],
    postLandoFiles: ['.lando.local.yml'],
    pluginDirs: [landoPath, {
      path: atLandoPath,
      subdir: '.',
      namespace: '@lando'
    }],
    disablePlugins: ['@lando/argv', '@lando/mailhog', '@lando/phpmyadmin'],
    proxyName: 'vip-dev-env-proxy',
    userConfRoot: landoDir,
    home: fakeHomeDir,
    domain: 'vipdev.lndo.site',
    version: 'unknown'
  };
  return (0, _bootstrap.buildConfig)(config);
}
const appMap = new Map();
async function initLandoApplication(lando, instancePath) {
  const app = lando.getApp(instancePath);
  app.events.on('post-init', 1, () => {
    const initOnly = [];
    const services = app.config.services;
    Object.keys(services).forEach(serviceName => {
      if (services[serviceName].initOnly) {
        initOnly.push(serviceName);
        app.config.services[serviceName].scanner = false;
      }
    });
    app.services = app.services.filter(service => !initOnly.includes(service));
  });
  await app.init();
  return app;
}
async function regenerateLandofile(lando, instancePath) {
  const landoFile = _nodePath.default.join(instancePath, '.lando.yml');
  try {
    const now = new Date().toISOString().replace(/[^\d]/g, '').slice(0, -3);
    const backup = `${landoFile}.${now}`;
    await (0, _promises2.rename)(landoFile, backup);
    console.warn(_chalk.default.yellow('Backed up %s to %s'), landoFile, backup);
  } catch (err) {
    // Rename failed - possibly the file does not exist. Silently ignoring.
  }
  const slug = _nodePath.default.basename(instancePath);
  const currentInstanceData = (0, _devEnvironmentCore.readEnvironmentData)(slug);
  currentInstanceData.pullAfter = 0;
  await (0, _devEnvironmentCore.updateEnvironment)(lando, currentInstanceData);
}
async function landoRecovery(lando, instancePath, error) {
  debug('Error initializing Lando app', error);
  console.warn(_chalk.default.yellow('There was an error initializing Lando, trying to recover...'));
  try {
    await regenerateLandofile(lando, instancePath);
  } catch (err) {
    console.error(`${_chalk.default.bold.red('Recovery failed, aborting.')} Please recreate the environment or contact support.`);
    throw err;
  }
  console.error(_chalk.default.green('Recovery successful, trying to initialize again...'));
  try {
    return await initLandoApplication(lando, instancePath);
  } catch (initError) {
    console.error(`${_chalk.default.bold.red('Initialization failed, aborting.')} Please recreate the environment or contact support.`);
    throw initError;
  }
}
async function getLandoApplication(lando, instancePath) {
  const started = new Date();
  try {
    if (appMap.has(instancePath)) {
      return Promise.resolve(appMap.get(instancePath));
    }
    if (!(await (0, _devEnvironmentCore.doesEnvironmentExist)(instancePath))) {
      throw new Error(_devEnvironment.DEV_ENVIRONMENT_NOT_FOUND);
    }
    let app;
    try {
      app = await initLandoApplication(lando, instancePath);
    } catch (error) {
      app = await landoRecovery(lando, instancePath, error);
    }
    appMap.set(instancePath, app);
    return app;
  } finally {
    const duration = new Date().getTime() - started.getTime();
    debug('getLandoApplication() took %d ms', duration);
  }
}
async function bootstrapLando() {
  const started = new Date();
  try {
    const socket = await (0, _dockerUtils.getDockerSocket)();
    const config = await getLandoConfig();
    if (socket) {
      config.engineConfig = await (0, _dockerUtils.getEngineConfig)(socket);
    }
    const lando = new _lando.default(config);
    lando.events.once('pre-engine-build', async data => {
      const instanceData = (0, _devEnvironmentCore.readEnvironmentData)(data.name);
      let registryResolvable = false;
      try {
        registryResolvable = (await (0, _promises.lookup)('ghcr.io')).address.length > 0 || false;
        debug('Registry ghcr.io is resolvable');
      } catch (err) {
        debug('Registry ghcr.io is not resolvable, image pull might be broken.');
        registryResolvable = false;
      }
      const pull = registryResolvable && (instanceData.pullAfter ?? 0) < Date.now();
      if (Array.isArray(data.opts.pullable) && Array.isArray(data.opts.local) && data.opts.local.length === 0 && !pull) {
        // Setting `data.opts.pullable` to an empty array prevents Lando from pulling images with `docker pull`.
        // Note that if some of the images are not available, they will still be pulled by `docker-compose`.
        data.opts.local = data.opts.pullable;
        data.opts.pullable = [];
      }
      if (pull || !instanceData.pullAfter) {
        instanceData.pullAfter = Date.now() + 7 * 24 * 60 * 60 * 1000;
        await (0, _devEnvironmentCore.writeEnvironmentData)(data.name, instanceData);
      }
    });
    await lando.bootstrap();
    return lando;
  } finally {
    const duration = new Date().getTime() - started.getTime();
    debug('bootstrapLando() took %d ms', duration);
  }
}
async function landoStart(lando, instancePath) {
  const started = new Date();
  try {
    debug('Will start lando app on path:', instancePath);
    const app = await getLandoApplication(lando, instancePath);
    await app.start();
  } finally {
    const duration = new Date().getTime() - started.getTime();
    debug('landoStart() took %d ms', duration);
  }
}
async function landoLogs(lando, instancePath, options) {
  const started = new Date();
  try {
    debug('Will show lando logs on path:', instancePath, ' with options: ', options);
    const app = await getLandoApplication(lando, instancePath);
    const logTask = lando.tasks.find(task => task.command === 'logs');
    await logTask?.run({
      follow: options.follow,
      service: options.service,
      timestamps: options.timestamps,
      _app: app
    });
  } finally {
    const duration = new Date().getTime() - started.getTime();
    debug('landoLogs() took %d ms', duration);
  }
}
async function landoRebuild(lando, instancePath) {
  const started = new Date();
  try {
    debug('Will rebuild lando app on path:', instancePath);
    const app = await getLandoApplication(lando, instancePath);
    app.events.on('post-uninstall', async () => removeDevToolsVolumes(lando, app));
    await ensureNoOrphantProxyContainer(lando);
    await app.rebuild();
  } finally {
    const duration = new Date().getTime() - started.getTime();
    debug('landoRebuild() took %d ms', duration);
  }
}
async function getBridgeNetwork(lando) {
  const networkName = lando.config.networkBridge ?? 'lando_bridge_network';
  try {
    return await lando.engine.getNetwork(networkName).inspect();
  } catch (err) {
    debug('Error getting network %s: %s', networkName, err.message);
    return null;
  }
}
async function cleanUpLandoProxy(lando) {
  const network = await getBridgeNetwork(lando);
  if (network?.Containers && Object.keys(network.Containers).length === 1) {
    const proxy = lando.engine.docker.getContainer(lando.config.proxyContainer);
    try {
      await proxy.remove({
        force: true
      });
    } catch (err) {
      debug('Error removing proxy container: %s', err.message);
    }
  }
}
async function landoStop(lando, instancePath) {
  const started = new Date();
  try {
    debug('Will stop lando app on path:', instancePath);
    const app = await getLandoApplication(lando, instancePath);
    app.events.once('post-stop', () => cleanUpLandoProxy(lando));
    await app.stop();
  } finally {
    const duration = new Date().getTime() - started.getTime();
    debug('landoStop() took %d ms', duration);
  }
}
async function landoDestroy(lando, instancePath) {
  const started = new Date();
  try {
    debug('Will destroy lando app on path:', instancePath);
    const app = await getLandoApplication(lando, instancePath);
    app.events.once('post-stop', () => cleanUpLandoProxy(lando));
    await app.destroy();
  } finally {
    const duration = new Date().getTime() - started.getTime();
    debug('landoDestroy() took %d ms', duration);
  }
}
async function landoInfo(lando, instancePath, options = {}) {
  const started = new Date();
  try {
    const app = await getLandoApplication(lando, instancePath);
    const info = _utils.default.startTable(app);
    const reachableServices = app.info.filter(service => service.urls.length);
    reachableServices.forEach(service => info[`${service.service} urls`] = service.urls);
    const health = await checkEnvHealth(lando, instancePath);
    const frontEndUrl = app.info.find(service => 'nginx' === service.service)?.urls[0] ?? '';
    const extraService = await getExtraServicesConnections(lando, app);
    const appInfo = {
      slug: info.name.replace(/^vipdev/, ''),
      ...info,
      ...extraService
    };
    delete appInfo.name;
    const hasResults = Object.values(health).length > 0;
    const hasWarnings = Object.values(health).some(status => !status);
    if (hasResults && !hasWarnings) {
      appInfo.status = _chalk.default.green('UP');
    } else if (health.nginx) {
      appInfo.status = _chalk.default.yellow('PARTIALLY UP');
    } else {
      appInfo.status = _chalk.default.red('DOWN');
    }

    // Add login information
    if (frontEndUrl) {
      let loginUrl = `${frontEndUrl}wp-admin/`;
      if (options.autologinKey) {
        loginUrl += `?vip-dev-autologin=${options.autologinKey}`;
      }
      appInfo['Login URL'] = loginUrl;
      appInfo['Default username'] = 'vipgo';
      appInfo['Default password'] = 'password';
    }
    if (!options.suppressWarnings && hasWarnings) {
      let message = _chalk.default.bold.yellow('The following services have failed health checks:\n');
      Object.keys(health).forEach(service => {
        if (!health[service]) {
          message += `${_chalk.default.red(service)}\n`;
        }
      });
      appInfo['Health warnings'] = message;
    }

    // Add documentation link
    appInfo.Documentation = 'https://docs.wpvip.com/vip-local-development-environment/';
    return appInfo;
  } finally {
    const duration = new Date().getTime() - started.getTime();
    debug('landoInfo() took %d ms', duration);
  }
}
const extraServiceDisplayConfiguration = [{
  name: 'elasticsearch',
  label: 'enterprise search',
  protocol: 'http'
}, {
  name: 'phpmyadmin',
  // Skipping, as the phpmyadmin was already printed by the regular services
  skip: true
}, {
  name: 'mailhog',
  skip: true
}, {
  name: 'mailpit',
  skip: true
}];
async function getExtraServicesConnections(lando, app) {
  const extraServices = {};
  const allServices = await lando.engine.list({
    project: app.project
  });
  const defaultDisplayConfiguration = {
    skip: false,
    label: null,
    protocol: null
  };
  for (const service of allServices) {
    const displayConfiguration = extraServiceDisplayConfiguration.find(conf => conf.name === service.service) ?? defaultDisplayConfiguration;
    if (displayConfiguration.skip) {
      continue;
    }

    // eslint-disable-next-line no-await-in-loop
    const containerScan = service.id ? await lando.engine.docker.scan(service.id) : null;
    if (containerScan?.NetworkSettings.Ports) {
      const mappings = Object.values(containerScan.NetworkSettings.Ports).filter(externalMapping => externalMapping?.length);
      mappings[0]?.forEach(({
        HostIp: host,
        HostPort: port
      }) => {
        const label = displayConfiguration.label ?? service.service;
        const value = (displayConfiguration.protocol ? `${displayConfiguration.protocol}://` : '') + `${host}:${port}`;
        if (extraServices[label]) {
          extraServices[label] += `, ${value}`;
        } else {
          extraServices[label] = value;
        }
      });
    }
  }
  return extraServices;
}
async function tryResolveDomains(urls) {
  const domains = [...new Set(urls.filter(url => url.toLowerCase().startsWith('http')).map(url => {
    try {
      return new URL(url).hostname;
    } catch (err) {
      return undefined;
    }
  }).filter(domain => domain !== undefined))];
  const domainsToFix = [];
  for (const domain of domains) {
    try {
      // eslint-disable-next-line no-await-in-loop
      const address = await (0, _promises.lookup)(domain, 4);
      debug('%s resolves to %s', domain, address.address);
      if (address.address !== '127.0.0.1') {
        domainsToFix.push(domain);
        console.warn(_chalk.default.yellow.bold('WARNING:'), `${domain} resolves to ${address.address} instead of 127.0.0.1. Things may not work as expected.`);
      }
    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Unknown error';
      domainsToFix.push(domain);
      console.warn(_chalk.default.yellow.bold('WARNING:'), `Failed to resolve ${domain}: ${msg}`);
    }
  }
  if (domainsToFix.length) {
    console.warn(_chalk.default.yellow('Please add the following lines to the hosts file on your system:\n'));
    console.warn(domainsToFix.map(domain => `127.0.0.1 ${domain}`).join('\n'));
    console.warn(_chalk.default.yellow('\nLearn more: https://docs.wpvip.com/vip-local-development-environment/troubleshooting-dev-env/#h-resolve-networking-configuration-issues\n'));
  }
}
async function checkEnvHealth(lando, instancePath) {
  const urls = {};
  const now = new Date();
  const app = await getLandoApplication(lando, instancePath);
  app.info.filter(service => service.urls.length).forEach(service => {
    service.urls.forEach(url => {
      urls[url] = service.service;
    });
  });
  const urlsToScan = Object.keys(urls).filter(url => !url.includes('*'));
  await tryResolveDomains(urlsToScan);
  let scanResults = [];
  if (Array.isArray(app.urls)) {
    scanResults = app.urls;
    app.urls.forEach(entry => {
      // We use different status codes to see if the service is up.
      // We may consider the service is up when Lando considers it is down.
      if (entry.color !== 'red') {
        urlsToScan.splice(urlsToScan.indexOf(entry.url), 1);
      }
    });
  }
  if (urlsToScan.length) {
    scanResults = scanResults.concat(await app.scanUrls(urlsToScan, {
      max: 1,
      waitCodes: [502, 504]
    }));
  }
  const result = {};
  scanResults.forEach(scanResult => {
    result[urls[scanResult.url]] = scanResult.status;
  });
  const duration = new Date().getTime() - now.getTime();
  debug('checkEnvHealth took %d ms', duration);
  return result;
}
async function isEnvUp(lando, instancePath) {
  const now = new Date();
  const app = await getLandoApplication(lando, instancePath);
  const reachableServices = app.info.filter(service => service.urls.length);
  const webUrls = reachableServices.map(service => service.urls).flat().filter(url => !/^https?:\/\/(localhost|127\.0\.0\.1):/.exec(url));
  await tryResolveDomains(webUrls);
  const scanResult = await app.scanUrls(webUrls, {
    max: 1,
    waitCodes: [502, 504]
  });
  const duration = new Date().getTime() - now.getTime();
  debug('isEnvUp took %d ms', duration);

  // If all the URLs are reachable then the app is considered 'up'
  return scanResult.length > 0 && scanResult.filter(result => result.status).length === scanResult.length;
}
async function landoExec(lando, instancePath, toolName, args, options) {
  const app = await getLandoApplication(lando, instancePath);
  const tool = app.config.tooling[toolName];
  if (!tool) {
    throw new _userError.default(`${toolName} is not a known lando task`);
  }
  const savedArgv = process.argv;
  try {
    /*
    	lando is looking in both passed args and process.argv so we need to do a bit of hack to fake process.argv
    	so that lando doesn't try to interpret args not meant for wp.
    		Lando drops first 3 args (<node> <lando> <command>) from process.argv and process rest, so we will fake 3 args + the real args
    */
    process.argv = ['0', '1', '3'].concat(args);
    tool.app = app;
    tool.name = toolName;
    tool.dir = '/';
    if (options.stdio) {
      tool.stdio = options.stdio;
    }
    const task = (0, _build.default)(tool, lando);
    const argv = {
      // eslint-disable-next-line id-length
      _: args
    };
    await task.run(argv);
  } finally {
    process.argv = savedArgv;
  }
}
async function landoShell(lando, instancePath, service, user, command) {
  const app = await getLandoApplication(lando, instancePath);
  const shellTask = lando.tasks.find(task => task.command === 'ssh');
  if (!command.length) {
    const interactive = process.stdin.isTTY ? '-i' : '';
    command = ['/bin/sh', '-c', `if [ -x /bin/bash ]; then /bin/bash ${interactive}; else /bin/sh ${interactive}; fi; exit 0`];
  }
  debug('Running command "%o" in service "%s" as user "%s"', command, service, user);
  await shellTask?.run({
    command,
    service,
    user,
    _app: app
  });
}

/**
 * Dev-tools volumes can get stale and is not updated when the new version of dev-tools
 * image is installed. Removing it during rebuild ensures the content is freshly populated
 * on startup.
 *
 * @param {Lando} lando
 * @param {App}   app
 */
async function removeDevToolsVolumes(lando, app) {
  debug('Attempting to removing dev-tools volumes');
  const scanResult = await lando.engine.docker.listVolumes();
  const devToolsVolumeNames = scanResult.Volumes.map(volume => volume.Name)
  // eslint-disable-next-line security/detect-non-literal-regexp
  .filter(volumeName => new RegExp(`${app.project}.*devtools`).test(volumeName));
  debug('Will remove', devToolsVolumeNames);
  const removalPromises = devToolsVolumeNames.map(volumeName => removeVolume(lando, volumeName));
  await Promise.all(removalPromises);
}

/**
 * Remove volume
 */
async function removeVolume(lando, volumeName) {
  debug(`Removing devtools volume ${volumeName}`);
  const devToolsVolume = lando.engine.docker.getVolume(volumeName);
  try {
    await devToolsVolume.remove();
    debug(`${volumeName} volume removed`);
  } catch (err) {
    debug(`Failed to remove volume ${volumeName}`, err);
  }
}

/**
 * Sometimes the proxy network seems to disapper leaving only orphant stopped proxy container.
 * It seems to happen while restarting/powering off computer. This container would then failed
 * to start due to missing network.
 *
 * This function tries to detect such scenario and remove the orphant. So that regular flow
 * can safely add a network and a new proxy container.
 */
async function ensureNoOrphantProxyContainer(lando) {
  const proxyContainerName = lando.config.proxyContainer;
  const docker = lando.engine.docker;
  const containers = await docker.listContainers({
    all: true
  });
  const proxyContainerExists = containers.some(container => container.Names.includes(`/${proxyContainerName}`));
  if (!proxyContainerExists) {
    return;
  }
  const proxyContainer = docker.getContainer(proxyContainerName);
  const status = await proxyContainer.inspect();
  if (status.State.Running) {
    return;
  }
  await proxyContainer.remove();
}
function validateDockerInstalled(lando) {
  const {
    engine,
    composePlugin,
    compose
  } = lando.config.versions;
  lando.log.verbose('docker-engine version: %s', engine);
  if (!engine) {
    if (!lando.config.dockerBin) {
      throw new _userError.default('docker binary could not be located! Please follow the following instructions to install it - https://docs.docker.com/engine/install/');
    }
    throw new _userError.default('Failed to connect to Docker. Please verify that Docker engine (service) is running and follow the troubleshooting instructions for your platform.');
  }
  lando.log.verbose('docker-compose version: %s', compose);
  lando.log.verbose('compose plugin version: %s', composePlugin);
  if (!composePlugin) {
    if (!compose) {
      throw new Error('docker-compose binary could not be located! Please follow the following instructions to install it - https://docs.docker.com/compose/install/');
    }
    if (!(0, _semver.satisfies)(compose, '^2.0.0')) {
      throw new Error(`docker-compose version ${compose} is not supported. Please upgrade to version 2.0.0 or higher - https://docs.docker.com/compose/install/`);
    }
  }
}