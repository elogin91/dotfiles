#!/usr/bin/env node

/**
 * External dependencies
 */
"use strict";

var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _command = _interopRequireDefault(require("../lib/cli/command"));
var _devEnvironmentCli = require("../lib/dev-environment/dev-environment-cli");
var _devEnvironmentCore = require("../lib/dev-environment/dev-environment-core");
var _devEnvironmentLando = require("../lib/dev-environment/dev-environment-lando");
var _tracker = require("../lib/tracker");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Internal dependencies
 */
const debug = (0, _debug.default)('@automattic/vip:bin:dev-environment');
const exampleUsage = 'vip dev-env purge';
const usage = 'vip dev-env purge';
const examples = [{
  usage: `${exampleUsage}`,
  description: 'Destroy all local environments.'
}, {
  usage: `${exampleUsage} --force`,
  description: 'Destroy all local environments without requiring confirmation from the user.'
}, {
  usage: `${exampleUsage} --soft`,
  description: 'Remove the Docker containers and volumes of all local environments but preserve their configuration files.\n' + '      * Preserving the configuration files allows the local environments to be regenerated; new Docker containers and volumes will be created.'
}];
(0, _command.default)({
  usage
}).option('soft', 'Preserve an environment’s configuration files; allows an environment to be regenerated with the start command.').option('force', 'Skip confirmation.').examples(examples).argv(process.argv, async (arg, opt) => {
  debug('Args: ', arg, 'Options: ', opt);
  const allEnvNames = (0, _devEnvironmentCore.getAllEnvironmentNames)();
  const lando = await (0, _devEnvironmentLando.bootstrapLando)();
  if (allEnvNames.length === 0) {
    console.log('No environments to purge!');
    return;
  }
  if (!opt.force) {
    const purge = await (0, _devEnvironmentCli.promptForBoolean)('Are you sure you want to purge ALL existing local environments?', true);
    if (!purge) {
      return;
    }
  }
  const trackingInfo = {
    all: true
  };
  await (0, _tracker.trackEvent)('dev_env_purge_command_execute', trackingInfo);
  (0, _devEnvironmentCli.validateDependencies)(lando);
  const removeFiles = !(opt.soft || false);
  try {
    for (const slug of allEnvNames) {
      try {
        // eslint-disable-next-line no-await-in-loop
        await (0, _devEnvironmentCore.destroyEnvironment)(lando, slug, removeFiles);
        const message = _chalk.default.green('✓') + ' Environments purged.\n';
        console.log(message);
      } catch (error) {
        const trackingInfoChild = (0, _devEnvironmentCli.getEnvTrackingInfo)(slug);
        // eslint-disable-next-line no-await-in-loop
        await (0, _devEnvironmentCli.handleCLIException)(error, 'dev_env_purge_command_error', trackingInfoChild);
        process.exitCode = 1;
      }
    }
    await (0, _tracker.trackEvent)('dev_env_purge_command_success', trackingInfo);
  } catch (error) {
    await (0, _devEnvironmentCli.handleCLIException)(error, 'dev_env_purge_command_error', trackingInfo);
    process.exitCode = 1;
  }
});