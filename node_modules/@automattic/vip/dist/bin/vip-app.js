#!/usr/bin/env node
"use strict";

var _chalk = _interopRequireDefault(require("chalk"));
var _app = _interopRequireDefault(require("../lib/api/app"));
var _command = _interopRequireWildcard(require("../lib/cli/command"));
var _tracker = require("../lib/tracker");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
(0, _command.default)({
  requiredArgs: 1,
  format: true
}).example('vip app list', 'Retrieve a list of applications that can be accessed by the current authenticated VIP-CLI user.').example('vip app example-app', 'Retrieve information about the application named "example-app" and its environments.').example('WPVIP_DEPLOY_TOKEN=1234 vip @example-app.develop app deploy file.zip', 'Deploy a local archived file named "file.zip" that contains application code to a VIP Platform environment that has Custom Deployment enabled.').command('list', 'Retrieve a list of applications that can be accessed by the current authenticated VIP-CLI user.').command('deploy', 'Deploy an archived file of application code to an environment that has Custom Deployment enabled.').argv(process.argv, async arg => {
  await (0, _tracker.trackEvent)('app_command_execute');
  let res;
  try {
    res = await (0, _app.default)(arg[0], 'id,repo,name,environments{id,appId,name,type,branch,currentCommit,primaryDomain{name},launched,deploymentStrategy}');
  } catch (err) {
    await (0, _tracker.trackEvent)('app_command_fetch_error', {
      error: `App ${arg[0]} does not exist`
    });
    console.log(`App ${_chalk.default.blueBright(arg[0])} does not exist`);
    return;
  }
  if (!res || !res.environments) {
    await (0, _tracker.trackEvent)('app_command_fetch_error', {
      error: `App ${arg[0]} does not exist`
    });
    console.log(`App ${_chalk.default.blueBright(arg[0])} does not exist`);
    return;
  }
  await (0, _tracker.trackEvent)('app_command_success');

  // Clone the read-only response object so we can modify it
  const clonedResponse = Object.assign({}, res);
  const header = [{
    key: 'id',
    value: res.id
  }, {
    key: 'name',
    value: res.name
  }, {
    key: 'repo',
    value: res.repo
  }];
  clonedResponse.environments = clonedResponse.environments.map(env => {
    const clonedEnv = Object.assign({}, env);
    clonedEnv.name = (0, _command.getEnvIdentifier)(env);

    // Use the short version of git commit hash
    clonedEnv.currentCommit = clonedEnv.currentCommit.substring(0, 7);

    // Flatten object
    clonedEnv.primaryDomain = clonedEnv.primaryDomain.name;

    // Set branch to empty for custom deployments
    if (clonedEnv.deploymentStrategy === 'custom-deploy') {
      clonedEnv.branch = '-';
    }

    // Hide "deployment strategy" column
    delete clonedEnv.deploymentStrategy;
    return clonedEnv;
  });
  return {
    header,
    data: clonedResponse.environments
  };
});