#!/usr/bin/env node
"use strict";

exports.__esModule = true;
exports.appQuery = void 0;
exports.followLogs = followLogs;
exports.getLogs = getLogs;
exports.validateInputs = validateInputs;
var _chalk = _interopRequireDefault(require("chalk"));
var _promises = require("timers/promises");
var logsLib = _interopRequireWildcard(require("../lib/app-logs/app-logs"));
var _command = _interopRequireDefault(require("../lib/cli/command"));
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _format = require("../lib/cli/format");
var _tracker = require("../lib/tracker");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const LIMIT_MIN = 1;
const LIMIT_MAX = 5000;
const ALLOWED_TYPES = ['app', 'batch'];
const ALLOWED_FORMATS = ['csv', 'json', 'table'];
const DEFAULT_POLLING_DELAY_IN_SECONDS = 30;
const MIN_POLLING_DELAY_IN_SECONDS = 5;
const MAX_POLLING_DELAY_IN_SECONDS = 300;

/**
 * @param {string[]} arg
 */
async function getLogs(arg, opt) {
  validateInputs(opt.type, opt.limit, opt.format);
  const trackingParams = getBaseTrackingParams(opt);
  await (0, _tracker.trackEvent)('logs_command_execute', trackingParams);
  let logs;
  try {
    if (opt.follow) {
      return await followLogs(opt);
    }
    logs = await logsLib.getRecentLogs(opt.app.id, opt.env.id, opt.type, opt.limit);
  } catch (error) {
    await (0, _tracker.trackEvent)('logs_command_error', {
      ...trackingParams,
      error: error.message
    });
    return exit.withError(error.message);
  }
  await (0, _tracker.trackEvent)('logs_command_success', {
    ...trackingParams,
    total: logs.nodes.length
  });
  if (!logs.nodes.length) {
    console.error('No logs found');
    return;
  }
  printLogs(logs.nodes, opt.format);
}
async function followLogs(opt) {
  let after = null;
  let isFirstRequest = true;
  // How many times have we polled?
  let requestNumber = 0;
  const trackingParams = getBaseTrackingParams(opt);

  // Set an initial default delay
  let delay = DEFAULT_POLLING_DELAY_IN_SECONDS;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const limit = isFirstRequest ? opt.limit : LIMIT_MAX;
    requestNumber++;
    trackingParams.request_number = requestNumber;
    trackingParams.request_delay = delay;
    trackingParams.limit = limit;
    let logs;
    try {
      // eslint-disable-next-line no-await-in-loop
      logs = await logsLib.getRecentLogs(opt.app.id, opt.env.id, opt.type, limit, after);

      // eslint-disable-next-line no-await-in-loop
      await (0, _tracker.trackEvent)('logs_command_follow_success', {
        ...trackingParams,
        total: logs?.nodes.length
      });
    } catch (error) {
      // eslint-disable-next-line no-await-in-loop
      await (0, _tracker.trackEvent)('logs_command_follow_error', {
        ...trackingParams,
        error: error.message
      });

      // If the first request fails we don't want to retry (it's probably not recoverable)
      if (isFirstRequest) {
        console.error(`${_chalk.default.red('Error:')} Failed to fetch logs.`);
        break;
      }
      // Increase the delay on errors to avoid overloading the server, up to a max of 5 minutes
      delay += DEFAULT_POLLING_DELAY_IN_SECONDS;
      delay = Math.min(delay, MAX_POLLING_DELAY_IN_SECONDS);
      console.error(`${_chalk.default.red('Error:')} Failed to fetch logs. Trying again in ${delay} seconds.`);
    }
    if (logs) {
      if (logs?.nodes.length) {
        printLogs(logs.nodes, opt.format);
      }
      after = logs?.nextCursor;
      isFirstRequest = false;

      // Keep a sane lower limit of MIN_POLLING_DELAY_IN_SECONDS just in case something goes wrong in the server-side
      delay = Math.max(logs?.pollingDelaySeconds || DEFAULT_POLLING_DELAY_IN_SECONDS, MIN_POLLING_DELAY_IN_SECONDS);
    }

    // eslint-disable-next-line no-await-in-loop
    await (0, _promises.setTimeout)(delay * 1000);
  }
}
function getBaseTrackingParams(opt) {
  return {
    command: 'vip logs',
    org_id: opt.app.organization.id,
    app_id: opt.app.id,
    env_id: opt.env.id,
    type: opt.type,
    limit: opt.limit,
    follow: opt.follow || false,
    format: opt.format
  };
}
function printLogs(logs, format) {
  // Strip out __typename
  logs = logs.map(log => {
    const {
      timestamp,
      message
    } = log;
    return {
      timestamp,
      message
    };
  });
  let output = '';
  if (format && 'table' === format) {
    const rows = [];
    for (const {
      timestamp,
      message
    } of logs) {
      rows.push(`${timestamp} ${message}`);
      output = rows.join('\n');
    }
  } else {
    output = (0, _format.formatData)(logs, format);
  }
  console.log(output);
}

/**
 * @param {string} type
 * @param {number} limit
 * @param {string} format
 */
function validateInputs(type, limit, format) {
  if (!ALLOWED_TYPES.includes(type)) {
    exit.withError(`Invalid type: ${type}. The supported types are: ${ALLOWED_TYPES.join(', ')}.`);
  }
  if (!ALLOWED_FORMATS.includes(format)) {
    exit.withError(`Invalid format: ${format}. The supported formats are: ${ALLOWED_FORMATS.join(', ')}.`);
  }
  if (!Number.isInteger(limit) || limit < LIMIT_MIN || limit > logsLib.LIMIT_MAX) {
    exit.withError(`Invalid limit: ${limit}. It should be a number between ${LIMIT_MIN} and ${logsLib.LIMIT_MAX}.`);
  }
}
const appQuery = exports.appQuery = `
	id
	name
	environments {
		id
		appId
		name
		type
	}
	organization {
		id
		name
	}
`;
(0, _command.default)({
  appContext: true,
  appQuery,
  envContext: true,
  module: 'logs'
}).option('type', 'The type of logs to be returned: "app" or "batch"', 'app').option('limit', 'The maximum number of log lines', 500).option('follow', 'Keep fetching new logs as they are generated').option('format', 'Output the log lines in CSV or JSON format', 'table').examples([{
  usage: 'vip @mysite.production logs',
  description: 'Get the most recent app logs'
}, {
  usage: 'vip @mysite.production logs --type batch',
  description: 'Get the most recent batch logs'
}, {
  usage: 'vip @mysite.production logs --limit 100',
  description: 'Get the most recent 100 log entries'
}, {
  usage: 'vip @mysite.production logs --limit 100 --format csv',
  description: 'Get the most recent 100 log entries formatted as comma-separated values (CSV)'
}, {
  usage: 'vip @mysite.production logs --limit 100 --format json',
  description: 'Get the most recent 100 log entries formatted as JSON'
}]).argv(process.argv, getLogs);