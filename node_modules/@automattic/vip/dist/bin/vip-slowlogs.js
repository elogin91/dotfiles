#!/usr/bin/env node
"use strict";

exports.__esModule = true;
exports.appQuery = void 0;
exports.followLogs = followLogs;
exports.getSlowlogs = getSlowlogs;
exports.validateInputs = validateInputs;
var _chalk = _interopRequireDefault(require("chalk"));
var _promises = require("timers/promises");
var slowlogsLib = _interopRequireWildcard(require("../lib/app-slowlogs/app-slowlogs"));
var _command = _interopRequireDefault(require("../lib/cli/command"));
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _format = require("../lib/cli/format");
var _tracker = require("../lib/tracker");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const LIMIT_MIN = 1;
const LIMIT_MAX = 500;
const ALLOWED_FORMATS = ['csv', 'json', 'table'];
const DEFAULT_POLLING_DELAY_IN_SECONDS = 30;
const MIN_POLLING_DELAY_IN_SECONDS = 5;
const MAX_POLLING_DELAY_IN_SECONDS = 300;
const exampleUsage = 'vip @example-app.develop slowlogs';
const baseUsage = 'vip slowlogs';
async function getSlowlogs(arg, opt) {
  validateInputs(opt.limit, opt.format);
  const trackingParams = getBaseTrackingParams(opt);
  await (0, _tracker.trackEvent)('slowlogs_command_execute', trackingParams);
  let slowlogs;
  try {
    slowlogs = await slowlogsLib.getRecentSlowlogs(opt.app.id, opt.env.id, opt.limit);
  } catch (error) {
    const err = error;
    await (0, _tracker.trackEvent)('slowlogs_command_error', {
      ...trackingParams,
      error: err.message
    });
    return exit.withError(err.message);
  }
  await (0, _tracker.trackEvent)('slowlogs_command_success', {
    ...trackingParams,
    total: slowlogs.nodes.length
  });
  if (!slowlogs.nodes.length) {
    console.error('No logs found');
    return;
  }
  printSlowlogs(slowlogs.nodes, opt.format);
}
async function followLogs(opt) {
  let after = null;
  let isFirstRequest = true;
  // How many times have we polled?
  let requestNumber = 0;
  const trackingParams = getBaseTrackingParams(opt);

  // Set an initial default delay
  let delay = DEFAULT_POLLING_DELAY_IN_SECONDS;

  // eslint-disable-next-line no-constant-condition, @typescript-eslint/no-unnecessary-condition
  while (true) {
    const limit = isFirstRequest ? opt.limit : LIMIT_MAX;
    requestNumber++;
    trackingParams.request_number = requestNumber;
    trackingParams.request_delay = delay;
    trackingParams.limit = limit;
    let slowlogs;
    try {
      // eslint-disable-next-line no-await-in-loop
      slowlogs = await slowlogsLib.getRecentSlowlogs(opt.app.id, opt.env.id, limit, after);

      // eslint-disable-next-line no-await-in-loop
      await (0, _tracker.trackEvent)('slowlogs_command_follow_success', {
        ...trackingParams,
        total: slowlogs.nodes.length
      });
    } catch (error) {
      const err = error;
      // eslint-disable-next-line no-await-in-loop
      await (0, _tracker.trackEvent)('slowlogs_command_follow_error', {
        ...trackingParams,
        error: err.message
      });

      // If the first request fails we don't want to retry (it's probably not recoverable)
      if (isFirstRequest) {
        console.error(`${_chalk.default.red('Error:')} Failed to fetch slowlogs.`);
        break;
      }
      // Increase the delay on errors to avoid overloading the server, up to a max of 5 minutes
      delay += DEFAULT_POLLING_DELAY_IN_SECONDS;
      delay = Math.min(delay, MAX_POLLING_DELAY_IN_SECONDS);
      console.error(`${_chalk.default.red('Error:')} Failed to fetch slowlogs. Trying again in ${delay} seconds.`);
    }
    if (slowlogs) {
      if (slowlogs.nodes.length) {
        printSlowlogs(slowlogs.nodes, opt.format);
      }
      after = slowlogs.nextCursor;
      isFirstRequest = false;

      // Keep a sane lower limit of MIN_POLLING_DELAY_IN_SECONDS just in case something goes wrong in the server-side
      delay = Math.max(slowlogs.pollingDelaySeconds || DEFAULT_POLLING_DELAY_IN_SECONDS, MIN_POLLING_DELAY_IN_SECONDS);
    }

    // eslint-disable-next-line no-await-in-loop
    await (0, _promises.setTimeout)(delay * 1000);
  }
}
function getBaseTrackingParams(opt) {
  return {
    command: 'vip slowlogs',
    org_id: opt.app.organization.id,
    app_id: opt.app.id,
    env_id: opt.env.id,
    limit: opt.limit,
    follow: opt.follow ?? false,
    format: opt.format
  };
}
function printSlowlogs(slowlogs, format) {
  // Strip out __typename
  slowlogs = slowlogs.map(log => {
    const {
      timestamp,
      rowsSent,
      rowsExamined,
      queryTime,
      requestUri,
      query
    } = log;
    return {
      timestamp,
      rowsSent,
      rowsExamined,
      queryTime,
      requestUri,
      query
    };
  });
  console.log((0, _format.formatData)(slowlogs, format));
}
function validateInputs(limit, format) {
  if (!ALLOWED_FORMATS.includes(format)) {
    exit.withError(`Invalid format: ${format}. The supported formats are: ${ALLOWED_FORMATS.join(', ')}.`);
  }
  if (!Number.isInteger(limit) || limit < LIMIT_MIN || limit > slowlogsLib.LIMIT_MAX) {
    exit.withError(`Invalid limit: ${limit}. It should be a number between ${LIMIT_MIN} and ${slowlogsLib.LIMIT_MAX}.`);
  }
}
const appQuery = exports.appQuery = `
	id
	name
	environments {
		id
		appId
		name
		type
	}
	organization {
		id
		name
	}
`;
void (0, _command.default)({
  appContext: true,
  appQuery,
  envContext: true,
  format: false,
  module: 'slowlogs',
  usage: baseUsage
}).option('limit', 'The maximum number of log entries', 500).option('format', 'Output the log entries in CSV or JSON format', 'table').examples([{
  description: 'Retrieve up to 500 of the most recent entries from the MySQL slow query logs in the default format.',
  usage: exampleUsage
}, {
  description: 'Retrieve up to 50 of the most recent entries from the MySQL slow query logs in the default format.',
  usage: `${exampleUsage} --limit=50`
}, {
  description: 'Retrieve up to 100 of the most recent entries from the MySQL slow query logs in CSV format.',
  usage: `${exampleUsage} --limit=100 --format=csv`
}, {
  description: 'Retrieve up to 100 of the most recent entries from the MySQL slow query logs in JSON format.',
  usage: `${exampleUsage} --limit=100 --format=json`
}]).argv(process.argv, getSlowlogs);