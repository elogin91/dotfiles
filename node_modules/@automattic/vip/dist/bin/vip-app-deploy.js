#!/usr/bin/env node

/**
 * External dependencies
 */
"use strict";

exports.__esModule = true;
exports.appDeployCmd = appDeployCmd;
exports.promptToContinue = promptToContinue;
var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _enquirer = require("enquirer");
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _api = _interopRequireDefault(require("../lib/api"));
var _command = _interopRequireDefault(require("../lib/cli/command"));
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _format = require("../lib/cli/format");
var _progress = require("../lib/cli/progress");
var _clientFileUploader = require("../lib/client-file-uploader");
var _customDeploy = require("../lib/custom-deploy/custom-deploy");
var _tracker = require("../lib/tracker");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Internal dependencies
 */
const START_DEPLOY_MUTATION = (0, _graphqlTag.default)`
	mutation StartCustomDeploy($input: AppEnvironmentCustomDeployInput) {
		startCustomDeploy(input: $input) {
			success
			message
		}
	}
`;
const debug = (0, _debug.default)('@automattic/vip:bin:vip-app-deploy');
const baseUsage = 'vip app deploy';
const DEPLOY_PREFLIGHT_PROGRESS_STEPS = [{
  id: 'upload',
  name: 'Uploading file'
}, {
  id: 'deploy',
  name: 'Triggering deployment'
}];
/**
 * Prompt the user to confirm the environment they are deploying to.
 * @param {PromptToContinueParams} PromptToContinueParams
 */
async function promptToContinue(params) {
  const promptToMatch = params.domain.toUpperCase();
  const promptResponse = await (0, _enquirer.prompt)({
    type: 'input',
    name: 'confirmedDomain',
    message: `You are about to deploy to a ${params.launched ? 'launched' : 'un-launched'} ${params.formattedEnvironment} site ${_chalk.default.yellow(params.domain)}.\nType '${_chalk.default.yellow(promptToMatch)}' (without the quotes) to continue:\n`
  });
  if (promptResponse.confirmedDomain.toUpperCase() !== promptToMatch) {
    await params.track('deploy_app_unexpected_input');
    exit.withError('The input did not match the expected environment label. Deploy aborted.');
  }
}
async function appDeployCmd(arg = [], opts = {}) {
  const app = opts.app;
  const env = opts.env;
  const [fileName] = arg;
  const fileMeta = await (0, _clientFileUploader.getFileMeta)(fileName);
  debug('Options: ', opts);
  debug('Args: ', arg);
  debug('Validating custom deploy key...');
  const {
    appId,
    envId,
    ...validatedArgs
  } = await (0, _customDeploy.validateCustomDeployKey)(app, env);
  debug('Validated environment data: ', {
    appId,
    envId,
    validatedArgs
  });
  const track = _tracker.trackEventWithEnv.bind(null, appId, envId);
  debug('Validating file...');
  await (0, _customDeploy.validateFile)(appId, envId, fileMeta);
  await track('deploy_app_command_execute');

  // Upload file as different name to avoid overwriting existing same named files
  const datePrefix = new Date().toISOString()
  // eslint-disable-next-line no-useless-escape
  .replace(/[\-T:\.Z]/g, '').slice(0, 14);
  fileMeta.basename = `${datePrefix}-${fileMeta.basename}`;
  const deployMessage = opts.message ?? '';
  const skipConfirm = opts.force || opts.skipConfirmation;
  if (!skipConfirm) {
    const promptParams = {
      launched: Boolean(validatedArgs.launched),
      formattedEnvironment: (0, _format.formatEnvironment)(validatedArgs.envType),
      track,
      domain: validatedArgs.primaryDomainName
    };
    await promptToContinue(promptParams);
  }

  /**
   * =========== WARNING =============
   *
   * NO `console.log` after this point!
   * Yes, even inside called functions.
   * It will break the progress printing.
   *
   * =========== WARNING =============
   */
  const progressTracker = new _progress.ProgressTracker(DEPLOY_PREFLIGHT_PROGRESS_STEPS);
  let status = 'running';
  const setProgressTrackerPrefixAndSuffix = () => {
    progressTracker.prefix = `
=============================================================
Processing the file for deployment to your environment...
`;
    progressTracker.suffix = `\n${(0, _format.getGlyphForStatus)(status, progressTracker.runningSprite)} Running...`;
  };
  const failWithError = failureError => {
    status = 'failed';
    setProgressTrackerPrefixAndSuffix();
    progressTracker.stopPrinting();
    progressTracker.print({
      clearAfter: true
    });
    exit.withError(failureError);
  };
  progressTracker.startPrinting(setProgressTrackerPrefixAndSuffix);
  progressTracker.stepRunning('upload');

  // Call the Public API
  const api = (0, _api.default)();
  const progressCallback = percentage => {
    progressTracker.setUploadPercentage(percentage);
  };
  const appInput = {
    id: appId
  };
  const envInput = {
    id: envId
  };
  const uploadParams = {
    app: appInput,
    env: envInput,
    fileMeta,
    progressCallback,
    hashType: 'sha256'
  };
  const startDeployVariables = {
    input: {}
  };
  try {
    const {
      fileMeta: {
        basename
      },
      checksum,
      result
    } = await (0, _clientFileUploader.uploadImportSqlFileToS3)(uploadParams);
    startDeployVariables.input = {
      id: appId,
      environmentId: envId,
      basename: fileMeta.basename,
      checksum,
      deployMessage
    };
    debug({
      basename,
      checksum,
      result,
      startDeployVariables
    });
    debug('Upload complete. Initiating the deploy.');
    progressTracker.stepSuccess('upload');
    await track('deploy_app_upload_complete');
  } catch (uploadError) {
    await track('deploy_app_command_error', {
      error_type: 'upload_failed',
      upload_error: uploadError.message
    });
    progressTracker.stepFailed('upload');
    return failWithError(uploadError);
  }
  progressTracker.stepRunning('deploy');

  // Start the deploy
  try {
    const WPVIP_DEPLOY_TOKEN = process.env.WPVIP_DEPLOY_TOKEN;
    const startDeployResults = await api.mutate({
      mutation: START_DEPLOY_MUTATION,
      variables: startDeployVariables,
      context: {
        headers: {
          Authorization: `Bearer ${WPVIP_DEPLOY_TOKEN}`
        }
      }
    });
    debug({
      startDeployResults
    });
  } catch (gqlErr) {
    progressTracker.stepFailed('deploy');
    await track('deploy_app_command_error', {
      error_type: 'StartDeploy-failed',
      gql_err: gqlErr
    });
    progressTracker.stepFailed('deploy');
    return failWithError(`StartDeploy call failed: ${gqlErr.message}`);
  }
  progressTracker.stepSuccess('deploy');
  progressTracker.stopPrinting();
  progressTracker.suffix = '';
  progressTracker.print({
    clearAfter: true
  });
  const deploymentsUrl = `https://dashboard.wpvip.com/apps/${appId}/${validatedArgs.envUniqueLabel}/code/deployments`;
  console.log(`\nâœ… ${_chalk.default.bold(_chalk.default.underline(_chalk.default.magenta(fileMeta.basename)))} has been sent for deployment to ${_chalk.default.bold(_chalk.default.blue(validatedArgs.primaryDomainName))}. \nTo check deployment status, go to ${_chalk.default.bold('VIP Dashboard')}: ${deploymentsUrl}`);
}

// Command examples for the `vip deploy app` help prompt
const examples = [
// `app` subcommand
{
  usage: 'WPVIP_DEPLOY_TOKEN=1234 vip @example-app.develop app deploy file.zip',
  description: 'Deploy a local archived file named "file.zip" that contains application code to a VIP Platform environment that has Custom Deployment enabled.'
}, {
  usage: 'WPVIP_DEPLOY_TOKEN=1234 vip @example-app.develop app deploy file.tgz --message="A description for this deploy"',
  description: 'Add a descriptive message for the Custom Deployment of the archived file named "file.tgz".'
}, {
  usage: 'WPVIP_DEPLOY_TOKEN=1234 vip @example-app.develop app deploy file.tar.gz --skip-confirmation',
  description: 'Skip the confirmation prompt for the Custom Deployment of the archived file named "file.tar.gz" to the environment.'
}];
void (0, _command.default)({
  requiredArgs: 1,
  usage: baseUsage
}).command('validate', 'Validate the directory structure of an archived file.').examples(examples).option('message', 'Add a description of a deployment.').option('skip-confirmation', 'Skip the confirmation prompt.').option('force', 'Skip confirmation prompt (deprecated)').option('app', 'Target an application. Accepts a string value for the application name or an integer for the application ID.').option('env', 'Target an environment. Accepts a string value for the environment type.').argv(process.argv, appDeployCmd);