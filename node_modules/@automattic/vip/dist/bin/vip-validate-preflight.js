#!/usr/bin/env node
"use strict";

exports.__esModule = true;
exports.appQuery = void 0;
exports.vipValidatePreflightCommand = vipValidatePreflightCommand;
var _vipGoPreflightChecks = require("@automattic/vip-go-preflight-checks");
var _chalk = _interopRequireDefault(require("chalk"));
var _enquirer = require("enquirer");
var _fs = require("fs");
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _ini = _interopRequireDefault(require("ini"));
var _path = _interopRequireDefault(require("path"));
var _api = _interopRequireWildcard(require("../lib/api"));
var _command = _interopRequireDefault(require("../lib/cli/command"));
var _envAlias = require("../lib/cli/envAlias");
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _tracker = require("../lib/tracker");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const ALLOWED_NODEJS_VERSIONS = ['14', '16', '18'];
const appQuery = exports.appQuery = `
	id
	name
	repo
	environments {
		id
		appId
		name
		type
		environmentVariables {
			nodes {
				name,
				value
			}
		}
	}
	organization {
		id
		name
	}
`;
let suppressOutput = false;
let outputJson = false;
let harmoniaArgs = [];

/**
 * @param {string[]} messages
 */
function logToConsole(...messages) {
  if (suppressOutput) {
    return;
  }
  if (messages.length === 0) {
    messages = [''];
  }
  messages.forEach(message => console.log(message));
}
async function getBuildConfiguration(application, environment) {
  const api = (0, _api.default)();

  // Disable the global GraphQL error handling, so we can catch Unauthorized errors and recommend next steps.
  (0, _api.disableGlobalGraphQLErrorHandling)();
  const buildConfigQuery = (0, _graphqlTag.default)`
		query BuildConfig($appId: Int, $envId: Int) {
			app(id: $appId) {
				environments(id: $envId) {
					id
					buildConfiguration {
						buildType
						nodeBuildDockerEnv
						nodeJSVersion
						npmToken
					}
				}
			}
		}
	`;
  try {
    const result = await api.query({
      query: buildConfigQuery,
      fetchPolicy: 'network-only',
      variables: {
        appId: environment.appId,
        envId: environment.id
      }
    });

    // Reenable GraphQL error handling
    (0, _api.enableGlobalGraphQLErrorHandling)();
    return result.data.app.environments[0].buildConfiguration;
  } catch (error) {
    if (error.graphQLErrors && error.graphQLErrors.find(gqlError => gqlError.message === 'Unauthorized')) {
      console.log(`${_chalk.default.red('Error:')} You don't have the required permissions to run validations for this environment.\n` + `You must be either be an admin of the ${_chalk.default.bold.underline(application.organization.name)} organization, or, alternatively,\n` + `a guest of that organization and an admin of the ${_chalk.default.bold.underline(application.name)} application.\n\n` + 'You can read more about organization and application roles on our documentation:\n' + _chalk.default.underline('https://docs.wpvip.com/manage-user-access/vip-dashboard/'));
      await (0, _tracker.trackEvent)('validate_preflight_command_error', {
        env_id: environment.id,
        app_id: environment.appId,
        error: 'unauthorized'
      });
      process.exit(1);
    } else {
      // Handle it elsewhere
      throw error;
    }
  }
}

/**
 * @param {string} argv
 */
async function vipValidatePreflightCommand(arg, opt) {
  harmoniaArgs = await validateArgs(opt);
  const appId = opt.env?.appId ?? 0;
  const envId = opt.env?.id ?? 0;
  const baseTrackingParams = {
    env_id: envId,
    app_id: appId,
    command: 'vip validate preflight',
    ...sanitizeArgsForTracking(harmoniaArgs)
  };
  await (0, _tracker.trackEvent)('validate_preflight_command_execute', baseTrackingParams);
  logToConsole('  /\\  /\\__ _ _ __ _ __ ___   ___  _ __ (_) __ _ ');
  logToConsole(" / /_/ / _` | '__| '_ ` _ \\ / _ \\| '_ \\| |/ _` |");
  logToConsole('/ __  / (_| | |  | | | | | | (_) | | | | | (_| |');
  logToConsole('\\/ /_/ \\__,_|_|  |_| |_| |_|\\___/|_| |_|_|\\__,_|');
  logToConsole('VIP Harmonia - Application testing made easy\n');
  const harmonia = new _vipGoPreflightChecks.Harmonia();
  harmonia.setSource('vip-cli');
  if (harmoniaArgs.buildType !== 'nodejs') {
    await (0, _tracker.trackEvent)('validate_preflight_command_error', {
      ...baseTrackingParams,
      error: 'not-nodejs'
    });
    exit.withError('Currently, only Node.js applications are supported.');
  }

  // Register the default tests.
  harmonia.registerDefaultTests();

  // Create the Site Config objects
  const siteOptions = new _vipGoPreflightChecks.SiteConfig({
    siteID: envId,
    nodejsVersion: harmoniaArgs.nodejsVersion,
    repository: opt.app?.repo ?? 'no-repo',
    baseURL: 'http://localhost:' + harmoniaArgs.port,
    dockerBuildEnvs: harmoniaArgs.nodeBuildDockerEnv,
    topRequests: [],
    // TODO: get top 10 of most requested URLs
    wait: harmoniaArgs.wait
  });

  // Get package.json
  const packageJSONfile = _path.default.resolve(opt.path, 'package.json');
  let packageJSON;
  try {
    // eslint-disable-next-line security/detect-non-literal-require
    packageJSON = require(packageJSONfile);
    siteOptions.setPackageJSON(packageJSON);
  } catch (error) {
    await (0, _tracker.trackEvent)('validate_preflight_command_error', {
      ...baseTrackingParams,
      error: 'missing-package-json'
    });
    return exit.withError(`Could not find a 'package.json' in the current folder (${opt.path}).`);
  }
  const customEnvVars = {};
  if (opt.env?.environmentVariables?.nodes.length > 0) {
    opt.env.environmentVariables.nodes.forEach(envVar => {
      customEnvVars[envVar.name] = envVar.value;
    });
  }

  // Create the EnviornmentVariables object
  const envVars = new _vipGoPreflightChecks.EnvironmentVariables({
    PORT: harmoniaArgs.port,
    ...customEnvVars
  });

  // Add NPM_TOKEN environment variable, if present
  if (harmoniaArgs.npmToken) {
    envVars.set('NPM_TOKEN', harmoniaArgs.npmToken);
  }

  // Get from .env, if exists
  let dotenvOptions = {};
  try {
    const dotenvPath = _path.default.resolve(opt.path, '.env');
    const dotenvContent = (0, _fs.readFileSync)(dotenvPath);
    dotenvOptions = _ini.default.parse(dotenvContent);
  } catch (error) {
    // nothing
  }

  // Save dotenv in the site config
  siteOptions.set('dotenv', dotenvOptions);

  // Bootstrap
  try {
    harmonia.bootstrap(siteOptions, envVars);
  } catch (error) {
    await (0, _tracker.trackEvent)('validate_preflight_command_error', {
      ...baseTrackingParams,
      error: error.message
    });
    return exit.withError(error.message);
  }
  setupEvents(harmonia);
  runHarmonia(harmonia);
}

/**
 * @param {Harmonia} harmonia
 */
function setupEvents(harmonia) {
  // Register some events handlers
  harmonia.on('ready', () => {
    logToConsole('Harmonia is ready! ');
  });

  // Register the event handlers to output some information during the execution
  harmonia.on('beforeTestSuite', suite => {
    const description = suite.description ? `- ${_chalk.default.italic(suite.description)}` : '';
    logToConsole(` >> Running test suite ${_chalk.default.bold(suite.name)} ${description} `);
    logToConsole();
  });
  harmonia.on('beforeTest', test => {
    logToConsole(`  [ ${_chalk.default.bold(test.name)} ] - ${test.description}`);
  });
  harmonia.on('afterTest', (test, result) => {
    switch (result.getType()) {
      case _vipGoPreflightChecks.TestResultType.Success:
        logToConsole(`   ✅  ${_chalk.default.bgGreen(' Test passed with no errors. ')}`);
        break;
      case _vipGoPreflightChecks.TestResultType.Failed:
        logToConsole(`   ❌  ${_chalk.default.bgRed(` Test failed with ${result.getErrors().length} errors. `)}`);
        break;
      case _vipGoPreflightChecks.TestResultType.PartialSuccess:
        logToConsole(`   ✅  ${_chalk.default.bgYellow(' Test partially succeeded. ')}`);
        break;
      case _vipGoPreflightChecks.TestResultType.Aborted:
        logToConsole(`   ❌  ${_chalk.default.bgRedBright.underline(' Test aborted! ')} - There was a critical error that makes`, 'the application incompatible with the VIP Platform.');
        break;
      case _vipGoPreflightChecks.TestResultType.Skipped:
        logToConsole(`  ${_chalk.default.bgGrey.bold(' Skipped ')}\t${result.getLastNotice().message}`);
    }
    logToConsole();
  });
  harmonia.on('afterTestSuite', (test, result) => {
    // Create a badge
    let badge;
    switch (result.getType()) {
      case _vipGoPreflightChecks.TestResultType.Failed:
        badge = _chalk.default.bgRed.bold(' FAILED ');
        break;
      case _vipGoPreflightChecks.TestResultType.Aborted:
        badge = _chalk.default.bgRedBright.underline.bold(' ABORTED ');
        break;
      case _vipGoPreflightChecks.TestResultType.PartialSuccess:
        badge = _chalk.default.bgYellow.bold(' PASS ');
        break;
      default:
        badge = _chalk.default.bgGreen.bold(' PASS ');
        break;
    }
    logToConsole(` >> ${badge} Finished running ${_chalk.default.bold(test.name)} suite`);
    logToConsole();
  });
  harmonia.on('issue', issue => {
    let issueTypeString = issue.getTypeString();
    switch (issue.type) {
      case _vipGoPreflightChecks.IssueType.Blocker:
        issueTypeString = _chalk.default.bgRedBright.underline.bold(issueTypeString);
        break;
      case _vipGoPreflightChecks.IssueType.Error:
        issueTypeString = _chalk.default.bgRed.bold(issueTypeString);
        break;
      case _vipGoPreflightChecks.IssueType.Warning:
        issueTypeString = _chalk.default.bgYellow.bold(issueTypeString);
        break;
      case _vipGoPreflightChecks.IssueType.Notice:
        issueTypeString = _chalk.default.bgGray.bold(issueTypeString);
        break;
    }
    const documentation = issue.documentation ? `(${issue.documentation})` : '';

    // Replace \n with \n\t\t to keep new lines aligned
    const message = issue.message.replace(/\n/g, '\n\t\t');
    logToConsole(`    ${issueTypeString} \t${message} ${documentation}`);

    // If it's a Blocker or Error, and the issue includes a stdout, print it out.
    const issueData = issue.getData();
    if (issueData && [_vipGoPreflightChecks.IssueType.Blocker, _vipGoPreflightChecks.IssueType.Error].includes(issue.type)) {
      if (issueData.all) {
        logToConsole(issueData.all);
        logToConsole();
      } else if (typeof issueData === 'string') {
        logToConsole(issueData);
        logToConsole();
      }
    }
  });
}
function runHarmonia(harmonia) {
  harmonia.run().then(async results => await handleResults(harmonia, results));
}
async function handleResults(harmonia, results) {
  // Calculate the results
  const resultCounter = harmonia.countResults(false);
  const testSuiteResults = results.filter(result => result instanceof _vipGoPreflightChecks.TestSuiteResult);

  // Send success event
  await (0, _tracker.trackEvent)('validate_preflight_command_success', {
    command: 'vip validate preflight',
    ...sanitizeArgsForTracking(harmoniaArgs),
    skipped: resultCounter[_vipGoPreflightChecks.TestResultType.Skipped],
    success: resultCounter[_vipGoPreflightChecks.TestResultType.Success],
    partial_success: resultCounter[_vipGoPreflightChecks.TestResultType.PartialSuccess],
    failed: resultCounter[_vipGoPreflightChecks.TestResultType.Failed],
    aborted: resultCounter[_vipGoPreflightChecks.TestResultType.Aborted]
  });

  // If the output is JSON, reenable the logToConsole output and print-out the json format.
  if (outputJson) {
    suppressOutput = false;
    logToConsole(harmonia.resultsJSON());
    process.exit(0);
  }

  // Print the results
  logToConsole('\n' + _chalk.default.bgGray('        HARMONIA RESULTS        \n'));
  if (resultCounter[_vipGoPreflightChecks.TestResultType.Skipped]) {
    logToConsole(` ${_chalk.default.bold.bgGrey(' SKIPPED ')} - ${_chalk.default.bold(resultCounter[_vipGoPreflightChecks.TestResultType.Skipped])} tests`);
  }
  if (resultCounter[_vipGoPreflightChecks.TestResultType.Success]) {
    logToConsole(` ${_chalk.default.bold.bgGreen(' PASSED ')} - ${_chalk.default.bold(resultCounter[_vipGoPreflightChecks.TestResultType.Success])} tests`);
  }
  if (resultCounter[_vipGoPreflightChecks.TestResultType.PartialSuccess]) {
    logToConsole(` ${_chalk.default.bold.bgYellow(' PARTIAL SUCCESS ')} - ${_chalk.default.bold(resultCounter[_vipGoPreflightChecks.TestResultType.PartialSuccess])} tests`);
  }
  if (resultCounter[_vipGoPreflightChecks.TestResultType.Failed]) {
    logToConsole(` ${_chalk.default.bold.bgRed(' FAILED ')} - ${_chalk.default.bold(resultCounter[_vipGoPreflightChecks.TestResultType.Failed])} tests`);
  }
  if (resultCounter[_vipGoPreflightChecks.TestResultType.Aborted]) {
    logToConsole(` ${_chalk.default.bold.bgRedBright(' ABORTED ')} - ${_chalk.default.bold(resultCounter[_vipGoPreflightChecks.TestResultType.Aborted])} tests`);
  }
  logToConsole();
  logToConsole(` > Total of ${_chalk.default.bold(results.length - testSuiteResults.length)} tests have been executed.`);
  logToConsole();

  // If there is a Aborted test result
  if (resultCounter[_vipGoPreflightChecks.TestResultType.Aborted]) {
    logToConsole(`${_chalk.default.bold.bgRedBright('  NOT PASS  ')} There was a critical failure that makes the application ` + 'incompatible with VIP Go. Please review the results and re-run the tests.');
    process.exit(1);
  }

  // If there is only a partial success, but no failures
  if (resultCounter[_vipGoPreflightChecks.TestResultType.PartialSuccess] && !resultCounter[_vipGoPreflightChecks.TestResultType.Failed]) {
    logToConsole(`${_chalk.default.bold.bgYellow('  PASS  ')} The application has passed the required tests, but it does not follow all the recommendations.`);
    logToConsole('Please review the results.');
    process.exit(0);
  }

  // If there is a failure
  if (resultCounter[_vipGoPreflightChecks.TestResultType.Failed]) {
    logToConsole(`${_chalk.default.bold.bgRed('  NOT PASS  ')} The application has failed some tests, and will very likely have problems in a production ` + 'environment. Please review all the errors found in the results.');
    process.exit(1);
  }
  logToConsole(`${_chalk.default.bold.bgGreen('  PASS  ')} Congratulations. The application passes all the tests.`);
  process.exit(0);
}
async function validateArgs(opt) {
  const args = {};

  // Verbose
  if (opt.verbose) {
    _vipGoPreflightChecks.Harmonia.setVerbosity(true);
  }

  // Set path
  if (opt.path) {
    _vipGoPreflightChecks.Harmonia.setCwd(opt.path);
  }

  // If the JSON option is enabled, all the stdout should be suppressed to prevent polluting the output.
  if (opt.json) {
    suppressOutput = true;
    outputJson = true;
  }
  if (opt.app) {
    // Get build information from API and store it in the env object
    const buildConfig = await getBuildConfiguration(opt.app, opt.env);
    args.app_id = opt.app.id;
    args.env_id = opt.env.id;
    args.nodejsVersion = opt.nodeVersion ?? buildConfig.nodeJSVersion;
    args.buildType = buildConfig.buildType;
    args.npmToken = buildConfig.npmToken;
    args.nodeBuildDockerEnv = buildConfig.nodeBuildDockerEnv;
  } else {
    args.app_id = 0;
    args.env_id = 0;
    args.buildType = 'nodejs';

    // If no node.js version is specified, prompt the user to select one
    if (!opt.nodeVersion) {
      // Ask for a node.js version
      try {
        const selection = await (0, _enquirer.prompt)({
          type: 'select',
          name: 'nodejsVersion',
          message: 'Which Node.js version do you want to use?',
          choices: ALLOWED_NODEJS_VERSIONS
        });
        args.nodejsVersion = selection.nodejsVersion;
      } catch (err) {
        exit.withError('No Node.js version selected. Aborting.');
      }
    } else {
      args.nodejsVersion = opt.nodeVersion;
    }
  }
  args.wait = opt.wait ?? 3000;
  args.port = opt.port ?? Math.floor(Math.random() * 1000) + 3001; // Get a PORT from 3001 and 3999

  return args;
}

/**
 * Remove sensitive information from the tracked events and snake_case the keys.
 *
 * @param {Object} args The arguments passed to the command.
 * @return {Object} Copy of the arguments without sensitive information.
 */
function sanitizeArgsForTracking(args) {
  const protectedKeys = ['npmToken', 'nodeBuildDockerEnv'];
  const sanitizedArgs = {};
  Object.entries(args).forEach(([key, value]) => {
    if (protectedKeys.includes(key)) {
      return;
    }
    // snake_case the key, as required by Tracks
    sanitizedArgs[key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`)] = value;
  });
  return sanitizedArgs;
}
let commandOpts = {
  module: 'harmonia'
};

// The @app.env selector is optional, so we need to check if it was passed
const parsedAlias = (0, _envAlias.parseEnvAliasFromArgv)(process.argv);
if (parsedAlias.app) {
  commandOpts = {
    ...commandOpts,
    appQuery,
    envContext: true,
    appContext: true
  };
} else {
  logToConsole(_chalk.default.bold.yellow('Warning: ') + 'The preflight tests are running without a provided application and/or environment.\n' + 'Some app-dependent configurations, such as environment variables, might not defined.');
}
(0, _command.default)(commandOpts).option('verbose', 'Increase logging level to include app build and server boot up messages', false).option('node-version', 'Select a specific target Node.JS version in semver format (MAJOR.MINOR.PATCH) or a MAJOR').option('wait', 'Configure the time to wait in ms for the app to boot up. Do not change unless you have issues', 3000).option(['p', 'port'], 'Configure the port to use for the app (defaults to a random port between 3001 and 3999)').option('json', 'Output the results as JSON', false).option(['P', 'path'], 'Path to the app to be tested', process.cwd()).examples([{
  usage: 'vip @mysite.production validate preflight',
  description: 'Runs the preflight tests to validate if your application is ready to be deployed to VIP Go'
}, {
  usage: 'vip @mysite.production validate preflight --json > results.json',
  description: 'Runs the preflight tests, but output the results in JSON format, and redirect the output to a file'
}]).argv(process.argv, vipValidatePreflightCommand);