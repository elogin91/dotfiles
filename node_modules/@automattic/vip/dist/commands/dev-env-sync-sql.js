#!/usr/bin/env node
"use strict";

exports.__esModule = true;
exports.DevEnvSyncSQLCommand = void 0;
var _vipSearchReplace = require("@automattic/vip-search-replace");
var _chalk = _interopRequireDefault(require("chalk"));
var _fs = _interopRequireDefault(require("fs"));
var _promises = require("node:stream/promises");
var _url = _interopRequireDefault(require("url"));
var _devEnvImportSql = require("./dev-env-import-sql");
var _exportSql = require("./export-sql");
var _backupStorageAvailability = require("../lib/backup-storage-availability/backup-storage-availability");
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _clientFileUploader = require("../lib/client-file-uploader");
var _database = require("../lib/database");
var _utils = require("../lib/utils");
var _lineByLine = require("../lib/validations/line-by-line");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Finds the site home url from the SQL line
 *
 * @param sql A line in a SQL file
 * @return Site home url. null if not found
 */
function findSiteHomeUrl(sql) {
  const regex = `['"](siteurl|home)['"],\\s?['"](.*?)['"]`;
  const url = sql.match(regex)?.[2] || '';
  return _url.default.parse(url).hostname || null;
}

/**
 * Extracts a list of site urls from the SQL file
 *
 * @param sqlFile Path to the SQL file
 * @return  List of site urls
 * @throws {Error} If there is an error reading the file
 */
async function extractSiteUrls(sqlFile) {
  const readInterface = await (0, _lineByLine.getReadInterface)(sqlFile);
  return new Promise((resolve, reject) => {
    const domains = new Set();
    readInterface.on('line', line => {
      const domain = findSiteHomeUrl(line);
      if (domain) {
        domains.add(domain);
      }
    });
    readInterface.on('close', () => {
      // Soring by length so that longest domains are replaced first
      resolve(Array.from(domains).sort((dom1, dom2) => dom2.length - dom1.length));
    });
    readInterface.on('error', reject);
  });
}
class DevEnvSyncSQLCommand {
  tmpDir;
  siteUrls = [];
  searchReplaceMap = {};
  _track;
  _sqlDumpType;

  /**
   * Creates a new instance of the command
   *
   * @param app       The app object
   * @param env       The environment object
   * @param slug      The site slug
   * @param lando     The lando object
   * @param trackerFn Function to call for tracking
   */
  constructor(app, env, slug, lando, trackerFn = () => {}) {
    this.app = app;
    this.env = env;
    this.slug = slug;
    this.lando = lando;
    this._track = trackerFn;
    this.tmpDir = (0, _utils.makeTempDir)();
  }
  track(name, eventProps) {
    return this._track(name, {
      ...eventProps,
      sqldump_type: this._sqlDumpType
    });
  }
  get landoDomain() {
    return `${this.slug}.${this.lando.config.domain}`;
  }
  get sqlFile() {
    return `${this.tmpDir}/sql-export.sql`;
  }
  get gzFile() {
    return `${this.tmpDir}/sql-export.sql.gz`;
  }
  getSqlDumpType() {
    if (!this._sqlDumpType) {
      throw new Error('SQL Dump type not initialized');
    }
    return this._sqlDumpType;
  }
  async initSqlDumpType() {
    const dumpDetails = await (0, _database.getSqlDumpDetails)(this.sqlFile);
    this._sqlDumpType = dumpDetails.type;
  }
  async confirmEnoughStorage(job) {
    const storageAvailability = _backupStorageAvailability.BackupStorageAvailability.createFromDbCopyJob(job);
    return await storageAvailability.validateAndPromptDiskSpaceWarningForDevEnvBackupImport();
  }

  /**
   * Runs the SQL export command to generate the SQL export from
   * the latest backup
   */
  async generateExport() {
    const exportCommand = new _exportSql.ExportSQLCommand(this.app, this.env, {
      outputFile: this.gzFile,
      confirmEnoughStorageHook: this.confirmEnoughStorage.bind(this)
    }, this.track.bind(this));
    await exportCommand.run();
  }

  /**
   * Runs the search-replace operation on the SQL file
   * to replace the site urls with the lando domain
   *
   * @return {Promise<void>} Promise that resolves when the search-replace is complete
   * @throws {Error} If there is an error reading the file
   */
  async runSearchReplace() {
    const replacements = Object.entries(this.searchReplaceMap).flat();
    const readStream = _fs.default.createReadStream(this.sqlFile);
    const replacedStream = await (0, _vipSearchReplace.replace)(readStream, replacements);
    const outputFile = `${this.tmpDir}/sql-export-sr.sql`;
    const streams = [replacedStream];
    if (this.getSqlDumpType() === _database.SqlDumpType.MYDUMPER) {
      streams.push((0, _database.fixMyDumperTransform)());
    }
    streams.push(_fs.default.createWriteStream(outputFile));
    await (0, _promises.pipeline)(streams);
    _fs.default.renameSync(outputFile, this.sqlFile);
  }
  generateSearchReplaceMap() {
    this.searchReplaceMap = {};
    for (const url of this.siteUrls) {
      this.searchReplaceMap[url] = this.landoDomain;
    }
    const networkSites = this.env.wpSitesSDS?.nodes;
    if (!networkSites) return;
    for (const site of networkSites) {
      if (!site?.blogId || site.blogId === 1) continue;
      const url = site?.homeUrl?.replace(/https?:\/\//, '');
      if (!url || !this.searchReplaceMap[url]) continue;
      this.searchReplaceMap[url] = `${this.slugifyDomain(url)}-${site.blogId}.${this.landoDomain}`;
    }
  }
  slugifyDomain(domain) {
    return String(domain).normalize('NFKD') // split accented characters into their base characters and diacritical marks
    .replace(/[\u0300-\u036f]/g, '') // remove all the accents, which happen to be all in the \u03xx UNICODE block.
    .trim() // trim leading or trailing whitespace
    .toLowerCase() // convert to lowercase
    .replace(/[^a-z0-9 .-]/g, '') // remove non-alphanumeric characters except for spaces, dots, and hyphens
    .replace(/[.\s]+/g, '-') // replace dots and spaces with hyphens
    .replace(/-+/g, '-'); // remove consecutive hyphens
  }

  /**
   * Runs the SQL import command to import the SQL file
   *
   * @return {Promise<void>} Promise that resolves when the import is complete
   * @throws {Error} If there is an error importing the file
   */
  async runImport() {
    const importOptions = {
      inPlace: true,
      skipValidate: true,
      quiet: true
    };
    const importCommand = new _devEnvImportSql.DevEnvImportSQLCommand(this.sqlFile, importOptions, this.slug);
    await importCommand.run();
  }

  /**
   * Sequentially runs the commands to export, search-replace, and import the SQL file
   * to the local environment
   *
   * @return Promise that resolves to true when the commands are complete. It will return false if the user did not continue during validation prompts.
   */
  async run() {
    try {
      await this.generateExport();
    } catch (err) {
      const error = err;
      // this.generateExport probably catches all exceptions, track the event and runs exit.withError() but if things go really wrong
      // and we have no tracking data, we would at least have it logged here.
      // the following will not get executed if this.generateExport() calls exit.withError() on all exception
      await this.track('error', {
        error_type: 'export_sql_backup',
        error_message: error.message,
        stack: error.stack
      });
      exit.withError(`Error exporting SQL backup: ${error.message}`);
    }
    try {
      console.log(`Extracting the exported file ${this.gzFile}...`);
      await (0, _clientFileUploader.unzipFile)(this.gzFile, this.sqlFile);
      await this.initSqlDumpType();
      console.log(`${_chalk.default.green('✓')} Extracted to ${this.sqlFile}`);
    } catch (err) {
      const error = err;
      await this.track('error', {
        error_type: 'archive_extraction',
        error_message: error.message,
        stack: error.stack
      });
      exit.withError(`Error extracting the SQL export: ${error.message}`);
    }
    try {
      console.log('Extracting site urls from the SQL file...');
      this.siteUrls = await extractSiteUrls(this.sqlFile);
    } catch (err) {
      const error = err;
      await this.track('error', {
        error_type: 'extract_site_urls',
        error_message: error.message,
        stack: error.stack
      });
      exit.withError(`Error extracting site URLs: ${error.message}`);
    }
    console.log('Generating search-replace configuration...');
    this.generateSearchReplaceMap();
    try {
      console.log('Running the following search-replace operations on the SQL file:');
      for (const [domain, landoDomain] of Object.entries(this.searchReplaceMap)) {
        console.log(`  ${domain} -> ${landoDomain}`);
      }
      await this.runSearchReplace();
      console.log(`${_chalk.default.green('✓')} Search-replace operation is complete`);
    } catch (err) {
      const error = err;
      await this.track('error', {
        error_type: 'search_replace',
        error_message: error.message,
        stack: error.stack
      });
      exit.withError(`Error replacing domains: ${error.message}`);
    }
    try {
      console.log('Importing the SQL file...');
      await this.runImport();
      console.log(`${_chalk.default.green('✓')} SQL file imported`);
    } catch (err) {
      const error = err;
      await this.track('error', {
        error_type: 'import_sql_file',
        error_message: error.message,
        stack: error.stack
      });
      exit.withError(`Error importing SQL file: ${error.message}`);
    }
    return true;
  }
}
exports.DevEnvSyncSQLCommand = DevEnvSyncSQLCommand;