"use strict";

exports.__esModule = true;
exports.DevEnvImportSQLCommand = void 0;
var _chalk = _interopRequireDefault(require("chalk"));
var _fs = _interopRequireDefault(require("fs"));
var _os = _interopRequireDefault(require("os"));
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _clientFileUploader = require("../lib/client-file-uploader");
var _database = require("../lib/database");
var _devEnvironmentCli = require("../lib/dev-environment/dev-environment-cli");
var _devEnvironmentCore = require("../lib/dev-environment/dev-environment-core");
var _devEnvironmentDatabase = require("../lib/dev-environment/dev-environment-database");
var _devEnvironmentLando = require("../lib/dev-environment/dev-environment-lando");
var _userError = _interopRequireDefault(require("../lib/user-error"));
var _utils = require("../lib/utils");
var _sql = require("../lib/validations/sql");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class DevEnvImportSQLCommand {
  constructor(fileName, options, slug) {
    this.fileName = fileName;
    this.options = options;
    this.slug = slug;
  }
  async run() {
    const lando = await (0, _devEnvironmentLando.bootstrapLando)();
    (0, _devEnvironmentCli.validateDependencies)(lando);
    (0, _sql.validateImportFileExtension)(this.fileName);
    const dumpDetails = await (0, _database.getSqlDumpDetails)(this.fileName);
    const isMyDumper = dumpDetails.type === _database.SqlDumpType.MYDUMPER;

    // Check if file is compressed and if so, extract the
    const fileMeta = await (0, _clientFileUploader.getFileMeta)(this.fileName);
    if (fileMeta.isCompressed) {
      const tmpDir = (0, _utils.makeTempDir)();
      const sqlFile = `${tmpDir}/sql-import.sql`;
      try {
        if (!this.options.quiet) {
          console.log(`Extracting the compressed file ${this.fileName}...`);
        }
        await (0, _clientFileUploader.unzipFile)(this.fileName, sqlFile);
        if (!this.options.quiet) {
          console.log(`${_chalk.default.green('âœ“')} Extracted to ${sqlFile}`);
        }
        this.fileName = sqlFile;
      } catch (error) {
        const err = error;
        exit.withError(`Error extracting the SQL file: ${err.message}`);
      }
    }
    const {
      searchReplace,
      inPlace
    } = this.options;
    const resolvedPath = await (0, _devEnvironmentCore.resolveImportPath)(this.slug, this.fileName, searchReplace, inPlace);
    if (!this.options.skipValidate) {
      if (!(await (0, _devEnvironmentLando.isEnvUp)(lando, (0, _devEnvironmentCore.getEnvironmentPath)(this.slug)))) {
        throw new _userError.default('Environment needs to be started first');
      }
      const expectedDomain = `${this.slug}.${lando.config.domain}`;
      await (0, _sql.validate)(resolvedPath, {
        isImport: false,
        skipChecks: isMyDumper ? ['dropTable', 'dropDB'] : [],
        extraCheckParams: {
          siteHomeUrlLando: expectedDomain
        }
      });
    }
    const fd = await _fs.default.promises.open(resolvedPath, 'r');
    const importArg = this.getImportArgs(dumpDetails);
    const origIsTTY = process.stdin.isTTY;
    try {
      /**
       * When stdin is a TTY, Lando passes the `--tty` flag to Docker.
       * This breaks our code when we pass the stream as stdin to Docker.
       * exec() then fails with "the input device is not a TTY".
       *
       * Therefore, for the things to work, we have to pretend that stdin is not a TTY :-)
       */
      process.stdin.isTTY = false;
      await (0, _devEnvironmentCore.exec)(lando, this.slug, importArg, {
        stdio: [fd, 'pipe', 'pipe']
      });
      if (!this.options.quiet) {
        console.log(`${_chalk.default.green.bold('Success:')} Database imported.`);
      }
    } finally {
      process.stdin.isTTY = origIsTTY;
    }
    if (searchReplace?.length && !inPlace) {
      _fs.default.unlinkSync(resolvedPath);
    }
    await (0, _devEnvironmentDatabase.flushCache)(lando, this.slug, this.options.quiet);
    if (undefined === this.options.skipReindex || !(0, _devEnvironmentCli.processBooleanOption)(this.options.skipReindex)) {
      try {
        await (0, _devEnvironmentDatabase.reIndexSearch)(lando, this.slug);
      } catch {
        // Exception means they don't have vip-search enabled.
      }
    }
    await (0, _devEnvironmentDatabase.addAdminUser)(lando, this.slug);
    await (0, _devEnvironmentDatabase.dataCleanup)(lando, this.slug, this.options.quiet);
  }
  getImportArgs(dumpDetails) {
    let importArg = ['db', '--disable-auto-rehash'].concat(this.options.quiet ? '--silent' : []);
    const threadCount = Math.max(_os.default.cpus().length - 2, 1);
    if (dumpDetails.type === _database.SqlDumpType.MYDUMPER) {
      importArg = ['db-myloader', '--overwrite-tables', `--source-db=${dumpDetails.sourceDb}`, `--threads=${threadCount}`, '--max-threads-for-schema-creation=10', '--max-threads-for-index-creation=10', '--skip-triggers', '--skip-post', '--innodb-optimize-keys', '--checksum=SKIP', '--metadata-refresh-interval=2000000', '--stream'].concat(this.options.quiet ? ['--verbose=0'] : ['--verbose=3']);
    }
    return importArg;
  }
}
exports.DevEnvImportSQLCommand = DevEnvImportSQLCommand;