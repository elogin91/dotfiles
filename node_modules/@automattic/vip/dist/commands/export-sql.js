"use strict";

exports.__esModule = true;
exports.GENERATE_DOWNLOAD_LINK_MUTATION = exports.ExportSQLCommand = exports.CREATE_EXPORT_JOB_MUTATION = void 0;
var _chalk = _interopRequireDefault(require("chalk"));
var _fs = _interopRequireDefault(require("fs"));
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _https = _interopRequireDefault(require("https"));
var _path = _interopRequireDefault(require("path"));
var _backupDb = require("./backup-db");
var _api = _interopRequireWildcard(require("../lib/api"));
var _backupStorageAvailability = require("../lib/backup-storage-availability/backup-storage-availability");
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _format = require("../lib/cli/format");
var _progress = require("../lib/cli/progress");
var _retry = require("../lib/retry");
var _utils = require("../lib/utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const EXPORT_SQL_PROGRESS_POLL_INTERVAL = 1000;
const BACKUP_AND_JOB_STATUS_QUERY = (0, _graphqlTag.default)`
	query AppBackupAndJobStatus($appId: Int!, $envId: Int!) {
		app(id: $appId) {
			id
			environments(id: $envId) {
				id
				latestBackup {
					id
					type
					size
					filename
					createdAt
				}
				jobs(jobTypes: [db_backup_copy]) {
					id
					type
					completedAt
					createdAt
					inProgressLock
					metadata {
						name
						value
					}
					progress {
						status
						steps {
							id
							name
							step
							status
						}
					}
				}
			}
		}
	}
`;

// Exporting for test purposes
const GENERATE_DOWNLOAD_LINK_MUTATION = exports.GENERATE_DOWNLOAD_LINK_MUTATION = (0, _graphqlTag.default)`
	mutation GenerateDBBackupCopyUrl($input: AppEnvironmentGenerateDBBackupCopyUrlInput) {
		generateDBBackupCopyUrl(input: $input) {
			url
			success
		}
	}
`;

// Exporting for test purposes
const CREATE_EXPORT_JOB_MUTATION = exports.CREATE_EXPORT_JOB_MUTATION = (0, _graphqlTag.default)`
	mutation BackupDBCopy($input: AppEnvironmentStartDBBackupCopyInput) {
		startDBBackupCopy(input: $input) {
			message
			success
		}
	}
`;

/**
 * Fetches the latest backup and job status for an environment
 *
 * @param {number} appId Application ID
 * @param {number} envId Environment ID
 * @return {Promise} A promise which resolves to the latest backup and job status
 */
async function fetchLatestBackupAndJobStatusBase(appId, envId) {
  const api = (0, _api.default)();
  const response = await api.query({
    query: BACKUP_AND_JOB_STATUS_QUERY,
    variables: {
      appId,
      envId
    },
    fetchPolicy: 'network-only'
  });
  const environments = response.data.app?.environments;
  const latestBackup = environments?.[0]?.latestBackup;
  const jobs = environments?.[0]?.jobs || [];
  return {
    latestBackup,
    jobs
  };
}
async function fetchLatestBackupAndJobStatus(appId, envId) {
  if (!appId || !envId) {
    throw new Error('App ID and Env ID missing');
  }
  return await (0, _retry.retry)({
    retryOnlyIf: options => {
      return (options.error.message || '').indexOf('Unexpected token < in JSON at position 0') !== -1;
    }
  }, () => fetchLatestBackupAndJobStatusBase(appId, envId));
}

/**
 * Generates a download link for a backup
 *
 * @param {number} appId    Application ID
 * @param {number} envId    Environment ID
 * @param {number} backupId Backup ID
 * @return {Promise} A promise which resolves to the download link
 */
async function generateDownloadLink(appId, envId, backupId) {
  if (!appId || !envId || !backupId) {
    throw new Error('generateDownloadLink: A parameter is missing');
  }
  const api = (0, _api.default)();
  const response = await api.mutate({
    mutation: GENERATE_DOWNLOAD_LINK_MUTATION,
    variables: {
      input: {
        id: appId,
        environmentId: envId,
        backupId
      }
    }
  });
  return response.data?.generateDBBackupCopyUrl?.url;
}

/**
 * Creates an export job for a backup
 *
 * @param {number} appId    Application ID
 * @param {number} envId    Environment ID
 * @param {number} backupId Backup ID
 * @return {Promise} A promise which resolves to undefined if job creation succeeds
 * @throws {Error} Throws an error if the job creation fails
 */
async function createExportJob(appId, envId, backupId) {
  if (!appId || !envId || !backupId) {
    throw new Error('createExportJob: Some fields are undefined');
  }

  // Disable global error handling so that we can handle errors ourselves
  (0, _api.disableGlobalGraphQLErrorHandling)();
  const api = (0, _api.default)();
  await api.mutate({
    mutation: CREATE_EXPORT_JOB_MUTATION,
    variables: {
      input: {
        id: appId,
        environmentId: envId,
        backupId
      }
    }
  });

  // Re-enable global error handling
  (0, _api.enableGlobalGraphQLErrorHandling)();
}
/**
 * Class representing an export command workflow
 */
class ExportSQLCommand {
  progressTracker;
  outputFile;
  generateBackup;
  confirmEnoughStorageHook;
  steps = {
    PREPARE: 'prepare',
    CREATE: 'create',
    DOWNLOAD_LINK: 'downloadLink',
    CONFIRM_ENOUGH_STORAGE: 'confirmEnoughStorage',
    DOWNLOAD: 'download'
  };
  track;

  /**
   * Creates an instance of SQLExportCommand
   *
   * @param {any}      app        The application object
   * @param {any}      env        The environment object
   * @param {object}   options 		The optional parameters
   * @param {Function} trackerFn  The progress tracker function
   */
  constructor(app, env, options = {}, trackerFn = () => {}) {
    this.app = app;
    this.env = env;
    this.outputFile = typeof options.outputFile === 'string' ? (0, _utils.getAbsolutePath)(options.outputFile) : null;
    this.confirmEnoughStorageHook = options.confirmEnoughStorageHook;
    this.generateBackup = options.generateBackup || false;
    this.progressTracker = new _progress.ProgressTracker([{
      id: this.steps.PREPARE,
      name: 'Preparing for backup download'
    }, {
      id: this.steps.CREATE,
      name: 'Creating backup copy'
    }, {
      id: this.steps.CONFIRM_ENOUGH_STORAGE,
      name: "Checking if there's enough storage"
    }, {
      id: this.steps.DOWNLOAD_LINK,
      name: 'Requesting download link'
    }, {
      id: this.steps.DOWNLOAD,
      name: 'Downloading file'
    }]);
    this.track = trackerFn;
  }

  /**
   * Fetches the export job of the latest backup
   *
   * @return {Promise} A promise which resolves to the export job
   */
  async getExportJob() {
    const {
      latestBackup,
      jobs
    } = await fetchLatestBackupAndJobStatus(this.app.id, this.env.id);
    if (!latestBackup) {
      return undefined;
    }

    // Find the job that generates the export for the latest backup
    return jobs.find(job => {
      const metadata = (job.metadata || []).find(md => md?.name === 'backupId');
      return metadata && parseInt(metadata.value, 10) === latestBackup.id;
    });
  }

  /**
   * Fetches the S3 filename of the exported backup
   *
   * @return A promise which resolves to the filename
   */
  async getExportedFileName() {
    const job = await this.getExportJob();
    if (!job) {
      throw new Error('Job not found');
    }
    const metadata = job.metadata?.find(md => md?.name === 'uploadPath');
    return metadata?.value?.split('/')[1];
  }

  /**
   * Downloads the exported file
   *
   * @param {string} url The download URL
   * @return {Promise} A promise which resolves to the path of the downloaded file
   * @throws {Error} Throws an error if the download fails
   */
  async downloadExportedFile(url) {
    const filename = this.outputFile || (await this.getExportedFileName()) || 'exported.sql.gz';
    const file = _fs.default.createWriteStream(filename);
    return new Promise((resolve, reject) => {
      _https.default.get(url, response => {
        response.pipe(file);
        const total = parseInt(response.headers['content-length'], 10);
        let current = 0;
        file.on('finish', () => {
          file.close();
          resolve(_path.default.resolve(file.path));
        });
        file.on('error', err => {
          // TODO: fs.unlink runs in the background so there's a chance that the app dies before it finishes.
          //  This needs fixing.
          _fs.default.unlink(filename, () => null);
          reject(err);
        });
        response.on('data', chunk => {
          current += chunk.length;
          this.progressTracker.setProgress(`- ${(100 * current / total).toFixed(2)}% (${(0, _format.formatBytes)(current)}/${(0, _format.formatBytes)(total)})`);
        });
      });
    });
  }

  /**
   * Checks if the export job's preflight step is successful
   *
   * @param job The export job
   * @return True if the preflight step is successful
   */
  isPrepared(job) {
    const step = job?.progress?.steps?.find(st => st?.id === 'preflight');
    return step?.status === 'success';
  }

  /**
   * Checks if the export job's S3 upload step is successful
   *
   * @param job The export job
   * @return True if the upload step is successful
   */
  isCreated(job) {
    const step = job?.progress?.steps?.find(st => st?.id === 'upload_backup');
    return step?.status === 'success';
  }

  /**
   * Stops the progress tracker
   */
  stopProgressTracker() {
    this.progressTracker.print();
    this.progressTracker.stopPrinting();
  }
  async runBackupJob() {
    const cmd = new _backupDb.BackupDBCommand(this.app, this.env);
    let noticeMessage = `\n${_chalk.default.yellow('NOTICE: ')}`;
    noticeMessage += 'If a recent database backup does not exist, a new one will be generated for this environment. ';
    noticeMessage += 'Learn more about this: https://docs.wpvip.com/databases/backups/download-a-full-database-backup/ \n';
    console.log(noticeMessage);
    await cmd.run(false);
  }
  async confirmEnoughStorage(job) {
    if (!job) {
      throw new Error('confirmEnoughStorage: job is missing');
    }
    if (this.confirmEnoughStorageHook) {
      return await this.confirmEnoughStorageHook(job);
    }
    const storageAvailability = _backupStorageAvailability.BackupStorageAvailability.createFromDbCopyJob(job);
    return await storageAvailability.validateAndPromptDiskSpaceWarningForBackupImport();
  }

  /**
   * Sequentially runs the steps of the export workflow
   *
   */
  async run() {
    if (this.outputFile) {
      try {
        _fs.default.accessSync(_path.default.parse(this.outputFile).dir, _fs.default.constants.W_OK);
      } catch (err) {
        const error = err;
        await this.track('error', {
          error_type: 'cannot_write_to_path',
          error_message: `Cannot write to the specified path: ${error?.message}`,
          stack: error?.stack
        });
        exit.withError(`Cannot write to the specified path: ${error?.message}`);
      }
    }
    if (this.generateBackup) {
      await this.runBackupJob();
    }
    const {
      latestBackup
    } = await fetchLatestBackupAndJobStatus(this.app.id, this.env.id);
    if (!latestBackup) {
      await this.track('error', {
        error_type: 'no_backup_found',
        error_message: 'No backup found for the site'
      });
      exit.withError(`No backup found for site ${this.app.name}`);
    }
    if (!this.generateBackup) {
      console.log(`${(0, _format.getGlyphForStatus)('success')} Latest backup found with timestamp ${latestBackup.createdAt}`);
    } else {
      console.log(`${(0, _format.getGlyphForStatus)('success')} Backup created with timestamp ${latestBackup.createdAt}`);
    }
    if (await this.getExportJob()) {
      console.log(`Attaching to an existing export for the backup with timestamp ${latestBackup.createdAt}`);
    } else {
      console.log(`Exporting database backup with timestamp ${latestBackup.createdAt}`);
      try {
        await createExportJob(this.app.id, this.env.id, latestBackup.id);
      } catch (err) {
        const error = err;
        // Todo: match error code instead of message substring
        if (error.message.includes('Backup Copy already in progress')) {
          await this.track('error', {
            error_type: 'job_already_running',
            error_message: error.message,
            stack: error.stack
          });
          exit.withError('There is an export job already running for this environment: ' + `https://dashboard.wpvip.com/apps/${this.app.id}/${this.env.uniqueLabel}/database/backups\n` + 'Currently, we allow only one export job at a time, per site. Please try again later.');
        } else {
          await this.track('error', {
            error_type: 'create_export_job',
            error_message: error.message,
            stack: error.stack
          });
        }
        exit.withError(`Error creating export job: ${error.message}`);
      }
    }
    this.progressTracker.stepRunning(this.steps.PREPARE);
    this.progressTracker.startPrinting();
    await (0, _utils.pollUntil)(this.getExportJob.bind(this), EXPORT_SQL_PROGRESS_POLL_INTERVAL, this.isPrepared.bind(this));
    this.progressTracker.stepSuccess(this.steps.PREPARE);
    await (0, _utils.pollUntil)(this.getExportJob.bind(this), EXPORT_SQL_PROGRESS_POLL_INTERVAL, this.isCreated.bind(this));
    this.progressTracker.stepSuccess(this.steps.CREATE);
    const storageConfirmed = await this.progressTracker.handleContinuePrompt(async setPromptShown => {
      const status = await this.confirmEnoughStorage(await this.getExportJob());
      if (status.isPromptShown) {
        setPromptShown();
      }
      return status.continue;
    });
    if (storageConfirmed) {
      this.progressTracker.stepSuccess(this.steps.CONFIRM_ENOUGH_STORAGE);
    } else {
      this.progressTracker.stepFailed(this.steps.CONFIRM_ENOUGH_STORAGE);
      this.stopProgressTracker();
      exit.withError('Command canceled by user.');
    }
    const url = await generateDownloadLink(this.app.id, this.env.id, latestBackup.id);
    this.progressTracker.stepSuccess(this.steps.DOWNLOAD_LINK);

    // The export file is prepared. Let's download it
    try {
      const filepath = await this.downloadExportedFile(url);
      this.progressTracker.stepSuccess(this.steps.DOWNLOAD);
      this.stopProgressTracker();
      console.log(`File saved to ${filepath}`);
    } catch (err) {
      const error = err;
      this.progressTracker.stepFailed(this.steps.DOWNLOAD);
      this.stopProgressTracker();
      await this.track('error', {
        error_type: 'download_failed',
        error_message: error.message,
        stack: error.stack
      });
      exit.withError(`Error downloading exported file: ${error.message}`);
    }
  }
}
exports.ExportSQLCommand = ExportSQLCommand;