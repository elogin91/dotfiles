"use strict";

exports.__esModule = true;
exports.DB_BACKUP_JOB_STATUS_QUERY = exports.CREATE_DB_BACKUP_JOB_MUTATION = exports.BackupDBCommand = void 0;
var _chalk = _interopRequireDefault(require("chalk"));
var _graphqlTag = _interopRequireDefault(require("graphql-tag"));
var _api = _interopRequireWildcard(require("../lib/api"));
var exit = _interopRequireWildcard(require("../lib/cli/exit"));
var _format = require("../lib/cli/format");
var _progress = require("../lib/cli/progress");
var _utils = require("../lib/utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const DB_BACKUP_PROGRESS_POLL_INTERVAL = 1000;
const CREATE_DB_BACKUP_JOB_MUTATION = exports.CREATE_DB_BACKUP_JOB_MUTATION = (0, _graphqlTag.default)`
	mutation TriggerDatabaseBackup($input: AppEnvironmentTriggerDBBackupInput) {
		triggerDatabaseBackup(input: $input) {
			success
		}
	}
`;
const DB_BACKUP_JOB_STATUS_QUERY = exports.DB_BACKUP_JOB_STATUS_QUERY = (0, _graphqlTag.default)`
	query AppBackupJobStatus($appId: Int!, $envId: Int!) {
		app(id: $appId) {
			id
			environments(id: $envId) {
				id
				jobs(jobTypes: [db_backup]) {
					id
					type
					completedAt
					createdAt
					inProgressLock
					metadata {
						name
						value
					}
					progress {
						status
					}
				}
			}
		}
	}
`;
async function getBackupJob(appId, envId) {
  const api = (0, _api.default)();
  const response = await api.query({
    query: DB_BACKUP_JOB_STATUS_QUERY,
    variables: {
      appId,
      envId
    },
    fetchPolicy: 'network-only'
  });
  const {
    data: {
      app
    }
  } = response;
  return app?.environments?.[0]?.jobs?.[0];
}
async function createBackupJob(appId, envId) {
  // Disable global error handling so that we can handle errors ourselves
  (0, _api.disableGlobalGraphQLErrorHandling)();
  const api = (0, _api.default)();
  await api.mutate({
    mutation: CREATE_DB_BACKUP_JOB_MUTATION,
    variables: {
      input: {
        id: appId,
        environmentId: envId
      }
    }
  });

  // Re-enable global error handling
  (0, _api.enableGlobalGraphQLErrorHandling)();
}

// Library for a possible command in the future: vip backup db @app.env
class BackupDBCommand {
  app;
  env;
  job;
  jobStatus;
  jobAge;
  backupName;
  silent;
  steps = {
    PREPARE: 'prepare',
    GENERATE: 'generate'
  };
  track;
  progressTracker;
  constructor(app, env, trackerFn = async () => {}) {
    this.app = app;
    this.env = env;
    this.progressTracker = new _progress.ProgressTracker([{
      id: this.steps.PREPARE,
      name: 'Preparing for backup generation'
    }, {
      id: this.steps.GENERATE,
      name: 'Generating backup'
    }]);
    this.track = trackerFn;
  }
  log(msg) {
    if (this.silent) {
      return;
    }
    console.log(msg);
  }
  isDone(job) {
    return !job?.inProgressLock;
  }

  /**
   * Stops the progress tracker
   *
   * @return {void}
   */
  stopProgressTracker() {
    this.progressTracker.print();
    this.progressTracker.stopPrinting();
  }
  async loadBackupJob() {
    this.job = await getBackupJob(this.app.id ?? 0, this.env.id ?? 0);
    this.backupName = this.job?.metadata?.find(meta => meta?.name === 'backupName')?.value ?? 'Unknown';
    this.jobStatus = this.job?.progress?.status ?? undefined;
    if (this.job?.completedAt) {
      this.jobAge = (new Date().getTime() - new Date(this.job.completedAt).getTime()) / 1000 / 60;
    } else {
      this.jobAge = undefined;
    }
    return this.job;
  }
  async run(silent = false) {
    this.silent = silent;
    await this.loadBackupJob();
    if (this.job?.inProgressLock) {
      this.log('Database backup already in progress...');
    } else {
      try {
        this.log('Generating a new database backup...');
        this.progressTracker.stepRunning(this.steps.PREPARE);
        this.progressTracker.startPrinting();
        await createBackupJob(this.app.id ?? 0, this.env.id ?? 0);
      } catch (err) {
        const error = err;
        const graphQLError = error.graphQLErrors?.[0];
        this.progressTracker.stepFailed(this.steps.PREPARE);
        this.stopProgressTracker();
        if (graphQLError?.extensions?.errorHttpCode === 429) {
          const retryAfter = graphQLError.extensions.retryAfter;
          await this.track('error', {
            error_type: 'rate_limit_exceeded',
            error_message: `Couldn't create a new database backup job: ${error.message}`,
            stack: error.stack
          });
          const errMessage = `A new database backup was not generated because a recently generated backup already exists.
If you would like to run the same command, you can retry in ${(0, _format.formatDuration)(new Date(), new Date(retryAfter))}
Alternatively, you can export the latest existing database backup by running: ${_chalk.default.green('vip @app.env export sql')}, right away.
Learn more about limitations around generating database backups: https://docs.wpvip.com/databases/backups/limitations/
					`;
          exit.withError(errMessage);
        }
        await this.track('error', {
          error_type: 'db_backup_job_creation_failed',
          error_message: `Database Backup job creation failed: ${error.message}`,
          stack: error.stack
        });
        exit.withError(`Couldn't create a new database backup job: ${error.message}`);
      }
    }
    this.progressTracker.stepSuccess(this.steps.PREPARE);
    this.progressTracker.stepRunning(this.steps.GENERATE);
    try {
      await (0, _utils.pollUntil)(this.loadBackupJob.bind(this), DB_BACKUP_PROGRESS_POLL_INTERVAL, this.isDone.bind(this));
    } catch (err) {
      const error = err;
      this.progressTracker.stepFailed(this.steps.GENERATE);
      this.stopProgressTracker();
      await this.track('error', {
        error_type: 'db_backup_job_failed',
        error_message: `Database Backup job failed: ${error.message}`,
        stack: error.stack
      });
      exit.withError(`Failed to create new database backup: ${error.message}`);
    }
    this.progressTracker.stepSuccess(this.steps.GENERATE);
    this.stopProgressTracker();
    await this.loadBackupJob();
    if (this.jobStatus !== 'success') {
      exit.withError('Failed to create a new database backup');
    } else {
      this.log('New database backup created');
    }
  }
}
exports.BackupDBCommand = BackupDBCommand;